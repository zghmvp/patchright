# NOTE: This patch file is generated automatically and is not used, it is only for documentation. The driver is actually patched using [patchright_driver_patch](https://github.com/Kaliiiiiiiiii-Vinyzu/patchright/blob/main/patchright_driver_patch.js), see [the workflow](https://github.com/Kaliiiiiiiiii-Vinyzu/patchright/blob/main/.github/workflows/patchright_workflow.yml)
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/browserContext.ts patchright/node_modules/playwright-core/src/server/browserContext.ts
---
+++
@@ -164,7 +164,7 @@
       await this.exposeConsoleApi();
 
     if (this._options.serviceWorkers === 'block')
-      await this.addInitScript(undefined, `\nif (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };\n`);
+      await this.addInitScript(undefined, `navigator.serviceWorker.register = async () => { };`);
 
     if (this._options.permissions)
       await this.grantPermissions(this._options.permissions);
@@ -354,27 +354,19 @@
       if (page.getBinding(name))
         throw new Error(`Function "${name}" has been already registered in one of the pages`);
     }
-    await progress.race(this.exposePlaywrightBindingIfNeeded());
     const binding = new PageBinding(name, playwrightBinding, needsHandle);
     binding.forClient = forClient;
     this._pageBindings.set(name, binding);
-    try {
-      await progress.race(this.doAddInitScript(binding.initScript));
-      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));
-      return binding;
-    } catch (error) {
-      this._pageBindings.delete(name);
-      throw error;
-    }
+    await this.doExposeBinding(binding);
   }
 
   async removeExposedBindings(bindings: PageBinding[]) {
-    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);
-    for (const binding of bindings)
-      this._pageBindings.delete(binding.name);
-    await this.doRemoveInitScripts(bindings.map(binding => binding.initScript));
-    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\n`).join('');
-    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');
+
+          for (const key of this._pageBindings.keys()) {
+            if (!key.startsWith('__pw')) this._pageBindings.delete(key);
+          }
+          await this.doRemoveExposedBindings();
+        
   }
 
   async grantPermissions(permissions: string[], origin?: string) {
@@ -491,9 +483,10 @@
   }
 
   async removeInitScripts(initScripts: InitScript[]) {
-    const set = new Set(initScripts);
-    this.initScripts = this.initScripts.filter(script => !set.has(script));
-    await this.doRemoveInitScripts(initScripts);
+
+          this.initScripts.splice(0, this.initScripts.length);
+          await this.doRemoveInitScripts();
+          
   }
 
   async addRequestInterceptor(progress: Progress, handler: network.RouteHandler): Promise<void> {
@@ -843,4 +836,5 @@
   strictSelectors: false,
   serviceWorkers: 'allow',
   locale: 'en-US',
+  focusControl: false
 };
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/chromium/chromiumSwitches.ts patchright/node_modules/playwright-core/src/server/chromium/chromiumSwitches.ts
---
+++
@@ -51,26 +51,16 @@
   '--disable-field-trial-config', // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
   '--disable-background-networking',
   '--disable-background-timer-throttling',
-  '--disable-backgrounding-occluded-windows',
-  '--disable-back-forward-cache', // Avoids surprises like main request not being intercepted during page.goBack().
-  '--disable-breakpad',
-  '--disable-client-side-phishing-detection',
-  '--disable-component-extensions-with-background-pages',
-  '--disable-component-update', // Avoids unneeded network activity after startup.
+  '--disable-backgrounding-occluded-windows', // Avoids surprises like main request not being intercepted during page.goBack().
+  '--disable-breakpad', // Avoids unneeded network activity after startup.
   '--no-default-browser-check',
-  '--disable-default-apps',
   '--disable-dev-shm-usage',
-  '--disable-extensions',
   '--disable-features=' + disabledFeatures(assistantMode).join(','),
   process.env.PLAYWRIGHT_LEGACY_SCREENSHOT ? '' : '--enable-features=CDPScreenshotNewSurface',
-  '--allow-pre-commit-input',
   '--disable-hang-monitor',
-  '--disable-ipc-flooding-protection',
-  '--disable-popup-blocking',
   '--disable-prompt-on-repost',
   '--disable-renderer-backgrounding',
   '--force-color-profile=srgb',
-  '--metrics-recording-only',
   '--no-first-run',
   '--password-store=basic',
   '--use-mock-keychain',
@@ -79,11 +69,8 @@
   '--export-tagged-pdf',
   // https://chromium-review.googlesource.com/c/chromium/src/+/4853540
   '--disable-search-engine-choice-screen',
-  // https://issues.chromium.org/41491762
-  '--unsafely-disable-devtools-self-xss-warnings',
   // Edge can potentially restart on Windows (msRelaunchNoCompatLayer) which looses its file descriptors (stdout/stderr) and CDP (3/4). Disable until fixed upstream.
   '--edge-skip-compat-layer-relaunch',
-  assistantMode ? '' : '--enable-automation',
   // This disables Chrome for Testing infobar that is visible in the persistent context.
   // The switch is ignored everywhere else, including Chromium/Chrome/Edge.
   '--disable-infobars',
@@ -91,4 +78,5 @@
   '--disable-search-engine-choice-screen',
   // Prevents the "three dots" menu crash in IdentityManager::HasPrimaryAccount for ephemeral contexts.
   android ? '' : '--disable-sync',
+  '--disable-blink-features=AutomationControlled'
 ].filter(Boolean);
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/chromium/crBrowser.ts patchright/node_modules/playwright-core/src/server/chromium/crBrowser.ts
---
+++
@@ -519,8 +519,9 @@
   }
 
   async doRemoveInitScripts(initScripts: InitScript[]) {
-    for (const page of this.pages())
-      await (page.delegate as CRPage).removeInitScripts(initScripts);
+
+          for (const page of this.pages()) await (page.delegate as CRPage).removeInitScripts();
+        
   }
 
   async doUpdateRequestInterception(): Promise<void> {
@@ -613,4 +614,16 @@
     const rootSession = await this._browser._clientRootSession();
     return rootSession.attachToTarget(targetId);
   }
+
+  async doExposeBinding(binding: PageBinding) {
+
+          for (const page of this.pages()) await (page.delegate as CRPage).exposeBinding(binding);
+        
+  }
+
+  async doRemoveExposedBindings() {
+
+          for (const page of this.pages()) await (page.delegate as CRPage).removeExposedBindings();
+        
+  }
 }
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/chromium/crDevTools.ts patchright/node_modules/playwright-core/src/server/chromium/crDevTools.ts
---
+++
@@ -64,7 +64,6 @@
       }).catch(e => null);
     });
     Promise.all([
-      session.send('Runtime.enable'),
       session.send('Runtime.addBinding', { name: kBindingName }),
       session.send('Page.enable'),
       session.send('Page.addScriptToEvaluateOnNewDocument', { source: `
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/chromium/crNetworkManager.ts patchright/node_modules/playwright-core/src/server/chromium/crNetworkManager.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -156,7 +158,7 @@
     const enabled = this._protocolRequestInterceptionEnabled;
     if (initial && !enabled)
       return;
-    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: enabled });
+    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: false });
     let fetchPromise = Promise.resolve<any>(undefined);
     if (!info.workerFrame) {
       if (enabled)
@@ -238,6 +240,7 @@
   }
 
   _onRequestPaused(sessionInfo: SessionInfo, event: Protocol.Fetch.requestPausedPayload) {
+    if (this._alreadyTrackedNetworkIds.has(event.networkId)) return;
     if (!event.networkId) {
       // Fetch without networkId means that request was not recognized by inspector, and
       // it will never receive Network.requestWillBeSent. Continue the request to not affect it.
@@ -276,6 +279,7 @@
   }
 
   _onRequest(requestWillBeSentSessionInfo: SessionInfo, requestWillBeSentEvent: Protocol.Network.requestWillBeSentPayload, requestPausedSessionInfo: SessionInfo | undefined, requestPausedEvent: Protocol.Fetch.requestPausedPayload | undefined) {
+    if (this._alreadyTrackedNetworkIds.has(requestWillBeSentEvent.initiator.requestId)) return;
     if (requestWillBeSentEvent.request.url.startsWith('data:'))
       return;
     let redirectedFrom: InterceptableRequest | null = null;
@@ -346,7 +350,7 @@
         }
         requestPausedSessionInfo!.session._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId, headers: headersOverride });
       } else {
-        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId);
+        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId, this._page, requestPausedEvent.networkId, this);
       }
     }
     const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';
@@ -557,6 +561,8 @@
     if (request.session !== sessionInfo.session && !sessionInfo.isMain && (request._documentId === request._requestId || sessionInfo.workerFrame))
       request.session = sessionInfo.session;
   }
+
+  _alreadyTrackedNetworkIds: Set<string> = new Set();
 }
 
 class InterceptableRequest {
@@ -615,38 +621,213 @@
   _alreadyContinuedParams: Protocol.Fetch.continueRequestParameters | undefined;
   _fulfilled: boolean = false;
 
-  constructor(session: CRSession, interceptionId: string) {
+  constructor(session: CRSession, interceptionId: string, page, networkId, sessionManager) {
+    this._sessionManager = void 0;
+    this._networkId = void 0;
+    this._page = void 0;
     this._session = session;
     this._interceptionId = interceptionId;
+    this._page = page;
+    this._networkId = networkId;
+    this._sessionManager = sessionManager;
+    eventsHelper.addEventListener(this._session, 'Fetch.requestPaused', async e => await this._networkRequestIntercepted(e));
   }
 
   async continue(overrides: types.NormalizedContinueOverrides): Promise<void> {
-    this._alreadyContinuedParams = {
-      requestId: this._interceptionId!,
-      url: overrides.url,
-      headers: overrides.headers,
-      method: overrides.method,
-      postData: overrides.postData ? overrides.postData.toString('base64') : undefined
-    };
-    await catchDisallowedErrors(async () => {
-      await this._session.send('Fetch.continueRequest', this._alreadyContinuedParams);
-    });
+
+          this._alreadyContinuedParams = {
+            requestId: this._interceptionId,
+            url: overrides.url,
+            headers: overrides.headers,
+            method: overrides.method,
+            postData: overrides.postData ? overrides.postData.toString('base64') : undefined,
+          };
+          if (overrides.url && (overrides.url === 'http://patchright-init-script-inject.internal/' || overrides.url === 'https://patchright-init-script-inject.internal/')) {
+            await catchDisallowedErrors(async () => {
+              this._sessionManager._alreadyTrackedNetworkIds.add(this._networkId);
+              this._session._sendMayFail('Fetch.continueRequest', { requestId: this._interceptionId, interceptResponse: true });
+            });
+          } else {
+            await catchDisallowedErrors(async () => {
+              await this._session._sendMayFail('Fetch.continueRequest', this._alreadyContinuedParams);
+            });
+          }
+        
   }
 
   async fulfill(response: types.NormalizedFulfillResponse) {
-    this._fulfilled = true;
-    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
 
-    const responseHeaders = splitSetCookieHeader(response.headers);
-    await catchDisallowedErrors(async () => {
-      await this._session.send('Fetch.fulfillRequest', {
-        requestId: this._interceptionId!,
-        responseCode: response.status,
-        responsePhrase: network.statusText(response.status),
-        responseHeaders,
-        body,
-      });
-    });
+          const isTextHtml = response.headers.some((header) => header.name.toLowerCase() === "content-type" && header.value.includes("text/html"));
+          var allInjections = [...this._page.delegate._mainFrameSession._evaluateOnNewDocumentScripts];
+          if (isTextHtml && allInjections.length) {
+            let useNonce = false;
+            let scriptNonce = null;
+            // Decode body if needed
+            if (response.isBase64) {
+              response.isBase64 = false;
+              response.body = Buffer.from(response.body, "base64").toString("utf-8");
+            }
+            // === CSP Detection and Fixing ===
+            const cspHeaderNames = ["content-security-policy", "content-security-policy-report-only"];
+            // Fix CSP in headers
+            for (let i = 0; i < response.headers.length; i++) {
+              const headerName = response.headers[i].name.toLowerCase();
+              if (cspHeaderNames.includes(headerName)) {
+                const originalCsp = response.headers[i].value || "";
+                // Extract nonce if present
+                if (!useNonce) {
+                  const nonceMatch = originalCsp.match(/script-src[^;]*'nonce-([^'"\s;]+)'/i);
+                  if (nonceMatch && nonceMatch[1]) {
+                    scriptNonce = nonceMatch[1];
+                    useNonce = true;
+                  }
+                }
+                
+                const fixedCsp = this._fixCSP(originalCsp, scriptNonce);
+                response.headers[i].value = fixedCsp;
+              }
+            }
+            
+            // Fix CSP in meta tags
+            if (typeof response.body === "string" && response.body.length) {
+              response.body = response.body.replace(
+                /<meta[^>]*http-equiv=(?:"|')?Content-Security-Policy(?:"|')?[^>]*>/gi,
+                (match) => {
+                  const contentMatch = match.match(/content=(?:"|')([^"']*)(?:"|')/i);
+                  if (contentMatch && contentMatch[1]) {
+                    let originalCsp = contentMatch[1];
+                    
+                    // Decode HTML entities
+                    originalCsp = originalCsp.replace(/&amp;/g, '&')  // Must be first!
+                        .replace(/&lt;/g, '<')
+                        .replace(/&gt;/g, '>')
+                        .replace(/&quot;/g, '"')
+                        .replace(/&#x27;/g, "'")
+                        .replace(/&#x22;/g, '"')
+                        .replace(/&nbsp;/g, ' ')
+                        .replace(/&#(d+);/g, (match, dec) => String.fromCharCode(dec))
+                        .replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));
+                    
+                    // Extract nonce if not already found
+                    if (!useNonce) {
+                      const nonceMatch = originalCsp.match(/script-src[^;]*'nonce-([^'"\s;]+)'/i);
+                      if (nonceMatch && nonceMatch[1]) {
+                        scriptNonce = nonceMatch[1];
+                        useNonce = true;
+                      }
+                    }
+                    
+                    const fixedCsp = this._fixCSP(originalCsp, scriptNonce);
+                    // Re-encode for HTML
+                    const encodedCsp = fixedCsp.replace(/'/g, '&#x27;').replace(/"/g, '&#x22;');
+                    return match.replace(contentMatch[1], encodedCsp);
+                  }
+                  return match;
+                }
+              );
+            }
+            
+            // Build injection HTML - only use nonce if one was found in existing CSP
+            let injectionHTML = "";
+            allInjections.forEach((script) => {
+              let scriptId = crypto.randomBytes(22).toString("hex");
+              let scriptSource = script.source || script;
+              const nonceAttr = useNonce ? `nonce="${scriptNonce}"` : '';
+              injectionHTML += `<script class="${this._page.delegate.initScriptTag}" ${nonceAttr} id="${scriptId}" type="text/javascript">document.getElementById("${scriptId}")?.remove();${scriptSource}</script>`;
+            });
+
+            // Inject at END of <head>
+            const lower = response.body.toLowerCase();
+            const headStartIndex = lower.indexOf("<head");
+            if (headStartIndex !== -1) {
+              const headEndTagIndex = lower.indexOf("</head>", headStartIndex);
+              if (headEndTagIndex !== -1) {
+                // Find the head opening tag end
+                const headOpenEnd = response.body.indexOf(">", headStartIndex) + 1;
+                const headContent = response.body.slice(headOpenEnd, headEndTagIndex);
+                const headContentLower = headContent.toLowerCase();
+                
+                // Look for the first <script> tag in the head content
+                // but ignore comments
+                let firstScriptIndex = -1;
+                let searchPos = 0;
+                const endSearchPos = headContentLower.length;
+
+                while (searchPos < endSearchPos) {
+                    const commentStart = headContentLower.indexOf("<!--", searchPos);
+                    const scriptStart = headContentLower.indexOf("<script", searchPos);
+                    // No more script tags, inject at the end of head content
+                    if (scriptStart === -1 || scriptStart >= endSearchPos) {
+                        break;
+                    }
+
+                    if (commentStart !== -1 && commentStart < scriptStart) {
+                        const commentEnd = headContentLower.indexOf("-->", commentStart);
+                        if (commentEnd !== -1) {
+                            // continue search after the comment
+                            searchPos = commentEnd + 3;
+                            continue;
+                        } else {
+                            break;
+                        }
+                    }
+
+                    // Found a script tag
+                    firstScriptIndex = scriptStart;
+                    break;
+                }
+                
+                if (firstScriptIndex !== -1) {
+                  // Inject before the first script tag
+                  const insertPosition = headOpenEnd + firstScriptIndex;
+                  response.body =
+                    response.body.slice(0, insertPosition) +
+                    injectionHTML +
+                    response.body.slice(insertPosition);
+                } else {
+                  // No script tags found, inject at the end of head content (before </head>)
+                  response.body =
+                    response.body.slice(0, headEndTagIndex) +
+                    injectionHTML +
+                    response.body.slice(headEndTagIndex);
+                }
+              } else {
+                const headStartTagEnd = response.body.indexOf(">", headStartIndex) + 1;
+                response.body =
+                  response.body.slice(0, headStartTagEnd) +
+                  injectionHTML +
+                  response.body.slice(headStartTagEnd);
+              }
+            } else {
+              const doctypeIndex = lower.indexOf("<!doctype");
+              if (doctypeIndex === 0) {
+                const doctypeEnd = response.body.indexOf(">", doctypeIndex) + 1;
+                response.body = response.body.slice(0, doctypeEnd) + injectionHTML + response.body.slice(doctypeEnd);
+              } else {
+                const htmlIndex = lower.indexOf("<html");
+                if (htmlIndex !== -1) {
+                  const htmlTagEnd = response.body.indexOf(">", htmlIndex) + 1;
+                  response.body =
+                    response.body.slice(0, htmlTagEnd) + `<head>${injectionHTML}</head>` + response.body.slice(htmlTagEnd);
+                } else {
+                  response.body = injectionHTML + response.body;
+                }
+              }
+            }
+          }
+          this._fulfilled = true;
+          const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
+          const responseHeaders = splitSetCookieHeader(response.headers);
+          await catchDisallowedErrors(async () => {
+            await this._session.send("Fetch.fulfillRequest", {
+              requestId: response.interceptionId ? response.interceptionId : this._interceptionId,
+              responseCode: response.status,
+              responsePhrase: network.statusText(response.status),
+              responseHeaders,
+              body
+            });
+          });
+        
   }
 
   async abort(errorCode: string = 'failed') {
@@ -659,6 +840,155 @@
       });
     });
   }
+
+  _fixCSP(csp, scriptNonce) {
+
+          if (!csp || typeof csp !== 'string') return csp;
+
+          // Split by semicolons and clean up
+          const directives = csp.split(';')
+            .map(d => d.trim())
+            .filter(d => d && d.length > 0);
+
+          const fixedDirectives = [];
+          let hasScriptSrc = false;
+
+          for (let directive of directives) {
+            // Skip empty directives
+            if (!directive.trim()) continue;
+
+            // Improved directive parsing to handle more edge cases
+            const directiveMatch = directive.match(/^([a-zA-Z-]+)\s+(.*)$/);
+            if (!directiveMatch) {
+              fixedDirectives.push(directive);
+              continue;
+            }
+
+            const directiveName = directiveMatch[1].toLowerCase();
+            const directiveValues = directiveMatch[2].split(/\s+/).filter(v => v.length > 0);
+
+            switch (directiveName) {
+              case 'script-src':
+                hasScriptSrc = true;
+                let values = [...directiveValues];
+
+                // Add nonce if we have one and it's not already present
+                if (scriptNonce && !values.some(v => v.includes(`nonce-${scriptNonce}`))) {
+                  values.push(`'nonce-${scriptNonce}'`);
+                }
+
+                // Add 'unsafe-eval' if not present
+                if (!values.includes("'unsafe-eval'")) {
+                  values.push("'unsafe-eval'");
+                }
+
+                // Add unsafe-inline if not present and no nonce is being used
+                if (!values.includes("'unsafe-inline'") && !scriptNonce) {
+                  values.push("'unsafe-inline'");
+                }
+
+                // Add wildcard for external scripts if not already present
+                if (!values.includes("*") && !values.includes("'self'") && !values.some(v => v.includes("https:"))) {
+                  values.push("*");
+                }
+
+                fixedDirectives.push(`script-src ${values.join(' ')}`);
+                break;
+
+              case 'style-src':
+                let styleValues = [...directiveValues];
+                // Add 'unsafe-inline' for styles if not present
+                if (!styleValues.includes("'unsafe-inline'")) {
+                  styleValues.push("'unsafe-inline'");
+                }
+                fixedDirectives.push(`style-src ${styleValues.join(' ')}`);
+                break;
+
+              case 'img-src':
+                let imgValues = [...directiveValues];
+                // Allow data: URLs for images if not already allowed
+                if (!imgValues.includes("data:") && !imgValues.includes("*")) {
+                  imgValues.push("data:");
+                }
+                fixedDirectives.push(`img-src ${imgValues.join(' ')}`);
+                break;
+
+              case 'font-src':
+                let fontValues = [...directiveValues];
+                // Allow data: URLs for fonts if not already allowed
+                if (!fontValues.includes("data:") && !fontValues.includes("*")) {
+                  fontValues.push("data:");
+                }
+                fixedDirectives.push(`font-src ${fontValues.join(' ')}`);
+                break;
+
+              case 'connect-src':
+                let connectValues = [...directiveValues];
+                // Allow WebSocket connections if not already allowed
+                const hasWs = connectValues.some(v => v.includes("ws:") || v.includes("wss:") || v === "*");
+                if (!hasWs) {
+                  connectValues.push("ws:", "wss:");
+                }
+                fixedDirectives.push(`connect-src ${connectValues.join(' ')}`);
+                break;
+
+              case 'frame-ancestors':
+                let frameAncestorValues = [...directiveValues];
+                // If completely blocked with 'none', allow 'self' at least
+                if (frameAncestorValues.includes("'none'")) {
+                  frameAncestorValues = ["'self'"];
+                }
+                fixedDirectives.push(`frame-ancestors ${frameAncestorValues.join(' ')}`);
+                break;
+
+              default:
+                // Keep other directives as-is
+                fixedDirectives.push(directive);
+                break;
+            }
+          }
+
+          // Add script-src if it doesn't exist (for our injected scripts)
+          if (!hasScriptSrc) {
+            if (scriptNonce) {
+              fixedDirectives.push(`script-src 'self' 'unsafe-eval' 'nonce-${scriptNonce}' *`);
+            } else {
+              fixedDirectives.push(`script-src 'self' 'unsafe-eval' 'unsafe-inline' *`);
+            }
+          }
+
+          return fixedDirectives.join('; ');
+        
+  }
+
+  async _networkRequestIntercepted(event) {
+
+          if (event.resourceType !== 'Document') {
+            /*await catchDisallowedErrors(async () => {
+              await this._session.send('Fetch.continueRequest', { requestId: event.requestId });
+            });*/
+            return;
+          }
+          if (this._networkId != event.networkId || !this._sessionManager._alreadyTrackedNetworkIds.has(event.networkId)) return;
+          try {
+            if (event.responseStatusCode >= 301 && event.responseStatusCode <= 308  || (event.redirectedRequestId && !event.responseStatusCode)) {
+              await this._session.send('Fetch.continueRequest', { requestId: event.requestId, interceptResponse: true });
+            } else {
+              const responseBody = await this._session.send('Fetch.getResponseBody', { requestId: event.requestId });
+              await this.fulfill({
+                headers: event.responseHeaders,
+                isBase64: true,
+                body: responseBody.body,
+                status: event.responseStatusCode,
+                interceptionId: event.requestId,
+                resourceType: event.resourceType,
+              })
+            }
+          } catch (error) {
+            await this._session._sendMayFail('Fetch.continueRequest', { requestId: event.requestId });
+          }
+        
+  }
 }
 
 // In certain cases, protocol will return error if the request was already canceled
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/chromium/crPage.ts patchright/node_modules/playwright-core/src/server/chromium/crPage.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -94,7 +96,8 @@
     this.updateOffline();
     this.updateExtraHTTPHeaders();
     this.updateHttpCredentials();
-    this.updateRequestInterception();
+    this._networkManager.setRequestInterception(true);
+        this.initScriptTag = crypto.randomBytes(20).toString('hex');
     this._mainFrameSession = new FrameSession(this, client, targetId, null);
     this._sessions.set(targetId, this._mainFrameSession);
     if (opener && !browserContext._options.noDefaultViewport) {
@@ -223,6 +226,7 @@
   }
 
   async addInitScript(initScript: InitScript, world: types.World = 'main'): Promise<void> {
+    this._page.initScripts.push(initScript);
     await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(initScript, world));
   }
 
@@ -356,6 +360,19 @@
   shouldToggleStyleSheetToSyncAnimations(): boolean {
     return false;
   }
+
+  async exposeBinding(binding) {
+
+          await this._forAllFrameSessions(frame => frame._initBinding(binding));
+          await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source).catch(e => {})));
+        
+  }
+
+  async removeExposedBindings() {
+
+          await this._forAllFrameSessions(frame => frame._removeExposedBindings());
+        
+  }
 }
 
 class FrameSession {
@@ -465,17 +482,6 @@
         this._bufferedAttachedToTargetEvents = undefined;
         for (const event of attachedToTargetEvents)
           this._onAttachedToTarget(event);
-
-        const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)!];
-        for (const frame of localFrames) {
-          // Note: frames might be removed before we send these.
-          this._client._sendMayFail('Page.createIsolatedWorld', {
-            frameId: frame._id,
-            grantUniveralAccess: true,
-            worldName: this._crPage.utilityWorldName,
-          });
-        }
-
         const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';
         if (isInitialEmptyPage) {
           // Ignore lifecycle events, worlds and bindings for the initial empty page. It is never the final page
@@ -485,13 +491,22 @@
             this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
           });
         } else {
+
+                  const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)!];
+                    for (const frame of localFrames) {
+                      this._page.frameManager.frame(frame._id)._context("utility");
+                      for (const binding of this._crPage._browserContext._pageBindings.values())
+                        frame.evaluateExpression(binding.source).catch(e => {});
+                      for (const source of this._crPage._browserContext.initScripts)
+                        frame.evaluateExpression(source).catch(e => {});
+                    }
+                  
           this._firstNonInitialNavigationCommittedFulfill();
           this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
         }
       }),
       this._client.send('Log.enable', {}),
       lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-      this._client.send('Runtime.enable', {}),
       this._client.send('Page.addScriptToEvaluateOnNewDocument', {
         source: '',
         worldName: this._crPage.utilityWorldName,
@@ -502,8 +517,10 @@
     if (!this._page.isStorageStatePage) {
       if (this._crPage._browserContext.needsPlaywrightBinding())
         promises.push(this.exposePlaywrightBinding());
-      if (this._isMainFrame())
-        promises.push(this._client.send('Emulation.setFocusEmulationEnabled', { enabled: true }));
+      
+              if (this._isMainFrame() && !this._crPage._browserContext._options.focusControl)
+                  promises.push(this._client.send("Emulation.setFocusEmulationEnabled", { enabled: true }));
+              
       const options = this._crPage._browserContext._options;
       if (options.bypassCSP)
         promises.push(this._client.send('Page.setBypassCSP', { enabled: true }));
@@ -526,14 +543,24 @@
       promises.push(this._updateGeolocation(true));
       promises.push(this._updateEmulateMedia());
       promises.push(this._updateFileChooserInterception(true));
-      for (const initScript of this._crPage._page.allInitScripts())
-        promises.push(this._evaluateOnNewDocument(initScript, 'main', true /* runImmediately */));
+      
+                    for (const binding of this._crPage._page.allBindings()) promises.push(this._initBinding(binding));
+                    for (const initScript of this._crPage._browserContext.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+                    for (const initScript of this._crPage._page.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+                  
       if (videoOptions)
         promises.push(this._crPage._page.screencast.startVideoRecording(videoOptions));
     }
-    promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+    
+            if (!(this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size))
+              promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+          
     promises.push(this._firstNonInitialNavigationCommittedPromise);
     await Promise.all(promises);
+
+            if (this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size)
+              await this._client.send('Runtime.runIfWaitingForDebugger');
+          
   }
 
   dispose() {
@@ -557,13 +584,25 @@
     return { newDocumentId: response.loaderId };
   }
 
-  _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
+  async _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
     if (this._eventBelongsToStaleFrame(event.frameId))
       return;
     if (event.name === 'load')
       this._page.frameManager.frameLifecycleEvent(event.frameId, 'load');
     else if (event.name === 'DOMContentLoaded')
       this._page.frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
+    await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          var document = await this._client._sendMayFail("DOM.getDocument");
+          if (!document) return
+          var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+            nodeId: document.root.nodeId,
+            selector: "[class=" + this._crPage.initScriptTag + "]"
+          });
+          if (!query) return
+          for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+          await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          // ensuring execution context
+          try { await this._page.frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _handleFrameTree(frameTree: Protocol.Page.FrameTree) {
@@ -610,12 +649,24 @@
     this._page.frameManager.frameAttached(frameId, parentFrameId);
   }
 
-  _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
+  async _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
     if (this._eventBelongsToStaleFrame(framePayload.id))
       return;
     this._page.frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);
     if (!initial)
       this._firstNonInitialNavigationCommittedFulfill();
+    await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          var document = await this._client._sendMayFail("DOM.getDocument");
+          if (!document) return
+          var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+            nodeId: document.root.nodeId,
+            selector: "[class=" + this._crPage.initScriptTag + "]"
+          });
+          if (!query) return
+          for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+          await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          // ensuring execution context
+          try { await this._page.frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _onFrameRequestedNavigation(payload: Protocol.Page.frameRequestedNavigationPayload) {
@@ -652,19 +703,31 @@
   }
 
   _onExecutionContextCreated(contextPayload: Protocol.Runtime.ExecutionContextDescription) {
+
+          for (const name of this._exposedBindingNames)
+            this._client._sendMayFail('Runtime.addBinding', { name: name, executionContextId: contextPayload.id });
+        
     const frame = contextPayload.auxData ? this._page.frameManager.frame(contextPayload.auxData.frameId) : null;
+
+          if (contextPayload.auxData.type == "worker") throw new Error("ExecutionContext is worker");
+        
     if (!frame || this._eventBelongsToStaleFrame(frame._id))
       return;
     const delegate = new CRExecutionContext(this._client, contextPayload);
-    let worldName: types.World|null = null;
-    if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
-      worldName = 'main';
-    else if (contextPayload.name === this._crPage.utilityWorldName)
-      worldName = 'utility';
+    let worldName = contextPayload.name;
     const context = new dom.FrameExecutionContext(delegate, frame, worldName);
     if (worldName)
       frame._contextCreated(worldName, context);
     this._contextIdToContext.set(contextPayload.id, context);
+
+          for (const source of this._exposedBindingScripts) {
+            this._client._sendMayFail("Runtime.evaluate", {
+              expression: source,
+              contextId: contextPayload.id,
+              awaitPromise: true,
+            })
+          }
+        
   }
 
   _onExecutionContextDestroyed(executionContextId: number) {
@@ -680,7 +743,7 @@
       this._onExecutionContextDestroyed(contextId);
   }
 
-  _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
+  async _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
     if (this._bufferedAttachedToTargetEvents) {
       this._bufferedAttachedToTargetEvents.push(event);
       return;
@@ -722,12 +785,22 @@
     session.once('Runtime.executionContextCreated', async event => {
       worker.createExecutionContext(new CRExecutionContext(session, event.context));
     });
+
+          var globalThis = await session._sendMayFail('Runtime.evaluate', {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          });
+          if (globalThis && globalThis.result) {
+            var globalThisObjId = globalThis.result.objectId;
+            var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+            worker.createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+          }
+        
     if (this._crPage._browserContext._browser.majorVersion() >= 143)
       session.on('Inspector.workerScriptLoaded', () => worker.workerScriptLoaded());
     else
       worker.workerScriptLoaded();
     // This might fail if the target is closed before we initialize.
-    session._sendMayFail('Runtime.enable');
     // TODO: attribute workers to the right frame.
     this._crPage._networkManager.addSession(session, this._page.frameManager.frame(this._targetId) ?? undefined).catch(() => {});
     session._sendMayFail('Runtime.runIfWaitingForDebugger');
@@ -1002,20 +1075,11 @@
   }
 
   async _evaluateOnNewDocument(initScript: InitScript, world: types.World, runImmediately?: boolean): Promise<void> {
-    const worldName = world === 'utility' ? this._crPage.utilityWorldName : undefined;
-    const { identifier } = await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: initScript.source, worldName, runImmediately });
-    this._initScriptIds.set(initScript, identifier);
+    this._evaluateOnNewDocumentScripts.push(initScript)
   }
 
   async _removeEvaluatesOnNewDocument(initScripts: InitScript[]): Promise<void> {
-    const ids: string[] = [];
-    for (const script of initScripts) {
-      const id = this._initScriptIds.get(script);
-      if (id)
-        ids.push(id);
-      this._initScriptIds.delete(script);
-    }
-    await Promise.all(ids.map(identifier => this._client.send('Page.removeScriptToEvaluateOnNewDocument', { identifier }).catch(() => {}))); // target can be closed
+    this._evaluateOnNewDocumentScripts = [];
   }
 
   async exposePlaywrightBinding() {
@@ -1126,6 +1190,48 @@
       throw new Error(dom.kUnableToAdoptErrorMessage);
     return createHandle(to, result.object).asElement()!;
   }
+
+  _exposedBindingNames: string[] = [];
+  _evaluateOnNewDocumentScripts: string[] = [];
+  _parsedExecutionContextIds: number[] = [];
+  _exposedBindingScripts: string[] = [];
+
+  async _initBinding(binding = PageBinding) {
+
+          var result = await this._client._sendMayFail('Page.createIsolatedWorld', {
+            frameId: this._targetId, grantUniveralAccess: true, worldName: "utility"
+          });
+          if (!result) return
+          var isolatedContextId = result.executionContextId
+
+          var globalThis = await this._client._sendMayFail('Runtime.evaluate', {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          });
+          if (!globalThis) return
+          var globalThisObjId = globalThis["result"]['objectId']
+          var mainContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+          await Promise.all([
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name }),
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: mainContextId }),
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: isolatedContextId }),
+            // this._client._sendMayFail("Runtime.evaluate", { expression: binding.source, contextId: mainContextId, awaitPromise: true })
+          ]);
+          this._exposedBindingNames.push(binding.name);
+          this._exposedBindingScripts.push(binding.source);
+          //this._client._sendMayFail('Runtime.runIfWaitingForDebugger')
+  }
+
+  async _removeExposedBindings() {
+    const toRetain: string[] = [];
+          const toRemove: string[] = [];
+          for (const name of this._exposedBindingNames)
+            (name.startsWith('__pw_') ? toRetain : toRemove).push(name);
+          this._exposedBindingNames = toRetain;
+          await Promise.all(toRemove.map(name => this._client.send('Runtime.removeBinding', { name })));
+        
+  }
 }
 
 async function emulateLocale(session: CRSession, locale: string) {
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/chromium/crServiceWorker.ts patchright/node_modules/playwright-core/src/server/chromium/crServiceWorker.ts
---
+++
@@ -58,13 +58,23 @@
       const message = new ConsoleMessage(null, this, event.type, undefined, args, toConsoleMessageLocation(event.stackTrace));
       this.browserContext.emit(BrowserContext.Events.Console, message);
     });
-
-    session.send('Runtime.enable', {}).catch(e => { });
     session.send('Runtime.runIfWaitingForDebugger').catch(e => { });
     session.on('Inspector.targetReloadedAfterCrash', () => {
       // Resume service worker after restart.
       session._sendMayFail('Runtime.runIfWaitingForDebugger', {});
     });
+
+          session._sendMayFail("Runtime.evaluate", {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          }).then(globalThis => {
+            if (globalThis && globalThis.result) {
+              var globalThisObjId = globalThis.result.objectId;
+              var executionContextId = parseInt(globalThisObjId.split(".")[1], 10);
+              this.createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+            }
+          });
+        
   }
 
   override didClose() {
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/clock.ts patchright/node_modules/playwright-core/src/server/clock.ts
---
+++
@@ -106,6 +106,16 @@
   }
 
   private async _evaluateInFrames(script: string) {
+
+          // Dont ask me why this works
+          await Promise.all(this._browserContext.pages().map(async page => {
+            await Promise.all(page.frames().map(async frame => {
+              try {
+                await frame.evaluateExpression("");
+              } catch (e) {}
+            }));
+          }));
+        
     await this._browserContext.safeNonStallingEvaluateInAllFrames(script, 'main', { throwOnJSErrors: true });
   }
 }
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/dispatchers/frameDispatcher.ts patchright/node_modules/playwright-core/src/server/dispatchers/frameDispatcher.ts
---
+++
@@ -84,11 +84,15 @@
   }
 
   async evaluateExpression(params: channels.FrameEvaluateExpressionParams, progress: Progress): Promise<channels.FrameEvaluateExpressionResult> {
-    return { value: serializeResult(await progress.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
+
+          return { value: serializeResult(await progress.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction, world: params.isolatedContext ? 'utility': 'main' }, parseArgument(params.arg)))) };
+        
   }
 
   async evaluateExpressionHandle(params: channels.FrameEvaluateExpressionHandleParams, progress: Progress): Promise<channels.FrameEvaluateExpressionHandleResult> {
-    return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
+
+          return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction, world: params.isolatedContext ? 'utility': 'main' }, parseArgument(params.arg)))) };
+        
   }
 
   async waitForSelector(params: channels.FrameWaitForSelectorParams, progress: Progress): Promise<channels.FrameWaitForSelectorResult> {
@@ -104,7 +108,9 @@
   }
 
   async evalOnSelectorAll(params: channels.FrameEvalOnSelectorAllParams, progress: Progress): Promise<channels.FrameEvalOnSelectorAllResult> {
-    return { value: serializeResult(await progress.race(this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg)))) };
+
+          return { value: serializeResult(await this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg), null, params.isolatedContext)) };
+        
   }
 
   async querySelector(params: channels.FrameQuerySelectorParams, progress: Progress): Promise<channels.FrameQuerySelectorResult> {
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/frameSelectors.ts patchright/node_modules/playwright-core/src/server/frameSelectors.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import { ElementHandle } from './dom';
 /**
  * Copyright (c) Microsoft Corporation.
  *
@@ -65,8 +67,8 @@
     return adoptIfNeeded(elementHandle, await resolved.frame._mainContext());
   }
 
-  async queryArrayInMainWorld(selector: string, scope?: ElementHandle): Promise<JSHandle<Element[]>> {
-    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: true }, scope);
+  async queryArrayInMainWorld(selector: string, scope?: ElementHandle, isolatedContext?: boolean): Promise<JSHandle<Element[]>> {
+    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: !isolatedContext }, scope);
     // Be careful, |this.frame| can be different from |resolved.frame|.
     if (!resolved)
       throw new Error(`Failed to find frame for selector "${selector}"`);
@@ -156,9 +158,31 @@
           throw injected.createStacklessError(`Selector "${selectorString}" resolved to ${injected.previewNode(element)}, <iframe> was expected`);
         return element;
       }, { info, scope: i === 0 ? scope : undefined, selectorString: stringifySelector(info.parsed) });
-      const element = handle.asElement() as ElementHandle<Element> | null;
-      if (!element)
-        return null;
+      let element = handle.asElement() as ElementHandle<Element> | null;
+      
+            if (!element) {
+              try {
+                var client = frame._page.delegate._sessionForFrame(frame)._client;
+              } catch (e) {
+                var client = frame._page.delegate._mainFrameSession._client;
+              }
+              var mainContext = await frame._context("main");
+              const documentNode = await client.send("Runtime.evaluate", {
+                expression: "document",
+                serializationOptions: {
+                  serialization: "idOnly"
+                },
+                contextId: mainContext.delegate._contextId
+              });
+              const documentScope = new ElementHandle(mainContext, documentNode.result.objectId);
+              var check = await this._customFindFramesByParsed(injectedScript, client, mainContext, documentScope, info.parsed);
+              if (check.length > 0) {
+                element = check[0];
+              } else {
+                return null;
+              }
+            }
+          
       const maybeFrame = await frame._page.delegate.getContentFrame(element);
       element.dispose();
       if (!maybeFrame)
@@ -179,9 +203,166 @@
     if (!resolved)
       return;
     const context = await resolved.frame._context(options?.mainWorld ? 'main' : resolved.info.world);
+    if (!context) throw new Error("Frame was detached");
     const injected = await context.injectedScript();
     return { injected, info: resolved.info, frame: resolved.frame, scope: resolved.scope };
   }
+
+  async _customFindFramesByParsed(injected, client, context, documentScope, parsed) {
+
+          var parsedEdits = { ...parsed };
+          var currentScopingElements = [documentScope];
+          while (parsed.parts.length > 0) {
+            var part = parsed.parts.shift();
+            parsedEdits.parts = [part];
+            var elements = [];
+            var elementsIndexes = [];
+            if (part.name == "nth") {
+              const partNth = Number(part.body);
+              if (partNth > currentScopingElements.length || partNth < -currentScopingElements.length) {
+                return continuePolling;
+              } else {
+                currentScopingElements = [currentScopingElements.at(partNth)];
+                continue;
+              }
+            } else if (part.name == "internal:or") {
+              var orredElements = await this._customFindFramesByParsed(injected, client, context, documentScope, part.body.parsed);
+              elements = currentScopingElements.concat(orredElements);
+            } else if (part.name == "internal:and") {
+              var andedElements = await this._customFindFramesByParsed(injected, client, context, documentScope, part.body.parsed);
+              const backendNodeIds = new Set(andedElements.map((item) => item.backendNodeId));
+              elements = currentScopingElements.filter((item) => backendNodeIds.has(item.backendNodeId));
+            } else {
+              for (const scope of currentScopingElements) {
+                const describedScope = await client.send("DOM.describeNode", {
+                  objectId: scope._objectId,
+                  depth: -1,
+                  pierce: true
+                });
+                var queryingElements = [];
+                let findClosedShadowRoots2 = function(node, results = []) {
+                  if (!node || typeof node !== "object") return results;
+                  if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                    for (const shadowRoot2 of node.shadowRoots) {
+                      if (shadowRoot2.shadowRootType === "closed" && shadowRoot2.backendNodeId) {
+                        results.push(shadowRoot2.backendNodeId);
+                      }
+                      findClosedShadowRoots2(shadowRoot2, results);
+                    }
+                  }
+                  if (node.nodeName !== "IFRAME" && node.children && Array.isArray(node.children)) {
+                    for (const child of node.children) {
+                      findClosedShadowRoots2(child, results);
+                    }
+                  }
+                  return results;
+                };
+                var findClosedShadowRoots = findClosedShadowRoots2;
+                var shadowRootBackendIds = findClosedShadowRoots2(describedScope.node);
+                var shadowRoots = [];
+                for (var shadowRootBackendId of shadowRootBackendIds) {
+                  var resolvedShadowRoot = await client.send("DOM.resolveNode", {
+                    backendNodeId: shadowRootBackendId,
+                    contextId: context.delegate._contextId
+                  });
+                  shadowRoots.push(new ElementHandle(context, resolvedShadowRoot.object.objectId));
+                }
+                for (var shadowRoot of shadowRoots) {
+                  const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed: parsed2 }]) => {
+                    const elements2 = injected.querySelectorAll(parsed2, node);
+                    return elements2;
+                  }, {
+                    parsed: parsedEdits,
+                  });
+                  const shadowElementsAmount = await shadowElements.getProperty("length");
+                  queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+                }
+                const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed: parsed2 }]) => {
+                  const elements2 = injected.querySelectorAll(parsed2, node);
+                  return elements2;
+                }, {
+                  parsed: parsedEdits
+                });
+                const rootElementsAmount = await rootElements.getProperty("length");
+                queryingElements.push([rootElements, rootElementsAmount, injected]);
+                for (var queryedElement of queryingElements) {
+                  var elementsToCheck = queryedElement[0];
+                  var elementsAmount = await queryedElement[1].jsonValue();
+                  var parentNode = queryedElement[2];
+                  for (var i = 0; i < elementsAmount; i++) {
+                    if (parentNode.constructor.name == "ElementHandle") {
+                      var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck: elementsToCheck2 }]) => {
+                        return elementsToCheck2[index];
+                      }, { index: i, elementsToCheck });
+                    } else {
+                      var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck: elementsToCheck2 }) => {
+                        return elementsToCheck2[index];
+                      }, { index: i, elementsToCheck });
+                    }
+                    elementToCheck.parentNode = parentNode;
+                    var resolvedElement = await client.send("DOM.describeNode", {
+                      objectId: elementToCheck._objectId,
+                      depth: -1
+                    });
+                    elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+                    elementToCheck.nodePosition = this._findElementPositionInDomTree(elementToCheck, describedScope.node, context, "");
+                    elements.push(elementToCheck);
+                  }
+                }
+              }
+            }
+            // Sorting elements by their nodePosition, which is a index to the Element in the DOM tree
+            const getParts = (pos) => (pos?.match(/../g) || []).map(Number);
+            elements.sort((a, b) => {
+              const partA = getParts(a.nodePosition);
+              const partB = getParts(b.nodePosition);
+              const maxLength = Math.max(partA.length, partB.length);
+
+              for (let i = 0; i < maxLength; i++) {
+                const aVal = partA[i] ?? -1;
+                const bVal = partB[i] ?? -1;
+                if (aVal !== bVal) return aVal - bVal;
+              }
+              return 0;
+            });
+
+            // Remove duplicates by nodePosition, keeping the first occurrence
+            currentScopingElements = Array.from(
+              new Map(elements.map(e => [e.nodePosition, e])).values()
+            );
+          }
+          return currentScopingElements;
+        
+  }
+
+  _findElementPositionInDomTree(element, queryingElement, documentScope, currentIndex) {
+
+          // Get Element Position in DOM Tree by Indexing it via their children indexes, like a search tree index
+          // Check if backendNodeId matches, if so, return currentIndex
+          if (element.backendNodeId === queryingElement.backendNodeId) {
+            return currentIndex;
+          }
+          // Iterating through children of queryingElement
+          for (const child of queryingElement.children || []) {
+            // Getting index of child in queryingElement's children
+            const childrenNodeIndex = queryingElement.children.indexOf(child);
+            // Further querying the child recursively and appending the children index to the currentIndex
+            const childIndex = this._findElementPositionInDomTree(element, child, documentScope, currentIndex + "." + childrenNodeIndex.toString());
+            if (childIndex !== null) return childIndex;
+          }
+          if (queryingElement.shadowRoots && Array.isArray(queryingElement.shadowRoots)) {
+            // Basically same for CSRs, but we dont have to append its index because patchright treats CSRs like they dont exist
+            for (const shadowRoot of queryingElement.shadowRoots) {
+              if (shadowRoot.shadowRootType === "closed" && shadowRoot.backendNodeId) {
+                const shadowRootHandle = new ElementHandle(documentScope, shadowRoot.backendNodeId);
+                const childIndex = this._findElementPositionInDomTree(element, shadowRootHandle, documentScope, currentIndex);
+                if (childIndex !== null) return childIndex;
+              }
+            }
+          }
+          return null;
+        
+  }
 }
 
 async function adoptIfNeeded<T extends Node>(handle: ElementHandle<T>, context: FrameExecutionContext): Promise<ElementHandle<T>> {
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/frames.ts patchright/node_modules/playwright-core/src/server/frames.ts
---
+++
@@ -1,3 +1,7 @@
+// patchright - custom imports
+import { CRExecutionContext } from './chromium/crExecutionContext';
+import { FrameExecutionContext } from './dom';
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -239,6 +243,9 @@
       // No pending - just commit a new document.
       frame._currentDocument = { documentId, request: undefined };
     }
+    frame._iframeWorld = undefined;
+    frame._mainWorld = undefined;
+    frame._isolatedWorld = undefined;
 
     frame._onClearLifecycle();
     const navigationEvent: NavigationEvent = { url, name, newDocument: frame._currentDocument, isPublic: true };
@@ -722,12 +729,69 @@
     return this._page.delegate.getFrameElement(this);
   }
 
-  _context(world: types.World): Promise<dom.FrameExecutionContext> {
-    return this._contextData.get(world)!.contextPromise.then(contextOrDestroyedReason => {
-      if (contextOrDestroyedReason instanceof js.ExecutionContext)
-        return contextOrDestroyedReason;
-      throw new Error(contextOrDestroyedReason.destroyedReason);
-    });
+  async _context(world: types.World): Promise<dom.FrameExecutionContext> {
+
+          /* await this._page.delegate._mainFrameSession._client._sendMayFail('DOM.enable');
+          var globalDoc = await this._page.delegate._mainFrameSession._client._sendMayFail('DOM.getFrameOwner', { frameId: this._id });
+          if (globalDoc) {
+            await this._page.delegate._mainFrameSession._client._sendMayFail("DOM.resolveNode", { nodeId: globalDoc.nodeId })
+          } */
+
+          if (this.isDetached()) throw new Error('Frame was detached');
+          try {
+            var client = this._page.delegate._sessionForFrame(this)._client
+          } catch (e) { var client = this._page.delegate._mainFrameSession._client }
+          var iframeExecutionContextId = await this._getFrameMainFrameContextId(client)
+
+          if (world == "main") {
+            // Iframe Only
+            if (this != this._page.mainFrame() && iframeExecutionContextId && this._iframeWorld == undefined) {
+              var executionContextId = iframeExecutionContextId
+              var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+              this._iframeWorld = new FrameExecutionContext(crContext, this, world)
+              this._page.delegate._mainFrameSession._onExecutionContextCreated({
+                id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+              })
+            } else if (this._mainWorld == undefined) {
+              var globalThis = await client._sendMayFail('Runtime.evaluate', {
+                expression: "globalThis",
+                serializationOptions: { serialization: "idOnly" }
+              });
+              if (!globalThis) { return }
+              var globalThisObjId = globalThis["result"]['objectId']
+              var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+              var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+              this._mainWorld = new FrameExecutionContext(crContext, this, world)
+              this._page.delegate._mainFrameSession._onExecutionContextCreated({
+                id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+              })
+            }
+          }
+          if (world != "main" && this._isolatedWorld == undefined) {
+            world = "utility"
+            var result = await client._sendMayFail('Page.createIsolatedWorld', {
+              frameId: this._id, grantUniveralAccess: true, worldName: world
+            });
+            if (!result) {
+              // if (this.isDetached()) throw new Error("Frame was detached");
+              return
+            }
+            var executionContextId = result.executionContextId
+            var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+            this._isolatedWorld = new FrameExecutionContext(crContext, this, world)
+            this._page.delegate._mainFrameSession._onExecutionContextCreated({
+              id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+            })
+          }
+
+          if (world != "main") {
+            return this._isolatedWorld;
+          } else if (this != this._page.mainFrame() && iframeExecutionContextId) {
+            return this._iframeWorld;
+          } else {
+            return this._mainWorld;
+          }
   }
 
   _mainContext(): Promise<dom.FrameExecutionContext> {
@@ -749,79 +813,73 @@
   }
 
   async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean, world?: types.World } = {}, arg?: any): Promise<js.JSHandle<any>> {
-    const context = await this._context(options.world ?? 'main');
-    const value = await context.evaluateExpressionHandle(expression, options, arg);
-    return value;
+
+          const context = await this._context(options.world ?? "utility");
+          const value = await context.evaluateExpressionHandle(expression, options, arg);
+          return value;
+        
   }
 
   async querySelector(selector: string, options: types.StrictOptions): Promise<dom.ElementHandle<Element> | null> {
-    debugLogger.log('api', `    finding element using the selector "${selector}"`);
-    return this.selectors.query(selector, options);
+
+          return this.querySelectorAll(selector, options).then((handles) => {
+            if (handles.length === 0)
+              return null;
+            if (handles.length > 1 && options?.strict)
+              throw new Error(`Strict mode: expected one element matching selector "${selector}", found ${handles.length}`);
+            return handles[0];
+          });
+        
   }
 
   async waitForSelector(progress: Progress, selector: string, performActionPreChecksAndLog: boolean, options: types.WaitForElementOptions, scope?: dom.ElementHandle): Promise<dom.ElementHandle<Element> | null> {
-    if ((options as any).visibility)
-      throw new Error('options.visibility is not supported, did you mean options.state?');
-    if ((options as any).waitFor && (options as any).waitFor !== 'visible')
-      throw new Error('options.waitFor is not supported, did you mean options.state?');
-    const { state = 'visible' } = options;
-    if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
-      throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
-    if (performActionPreChecksAndLog)
-      progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecksAndLog)
-        await this._page.performActionPreChecks(progress);
 
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved) {
-        if (state === 'hidden' || state === 'detached')
-          return null;
-        return continuePolling;
-      }
-      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, root }) => {
-        if (root && !root.isConnected)
-          throw injected.createStacklessError('Element is not attached to the DOM');
-        const elements = injected.querySelectorAll(info.parsed, root || document);
-        const element: Element | undefined  = elements[0];
-        const visible = element ? injected.utils.isElementVisible(element) : false;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`;
-        }
-        injected.checkDeprecatedSelectorUsage(info.parsed, elements);
-        return { log, element, visible, attached: !!element };
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));
-      const { log, visible, attached } = await progress.race(result.evaluate(r => ({ log: r.log, visible: r.visible, attached: r.attached })));
-      if (log)
-        progress.log(log);
-      const success = { attached, detached: !attached, visible, hidden: !visible }[state];
-      if (!success) {
-        result.dispose();
-        return continuePolling;
-      }
-      if (options.omitReturnValue) {
-        result.dispose();
-        return null;
-      }
-      const element = state === 'attached' || state === 'visible' ? await progress.race(result.evaluateHandle(r => r.element)) : null;
-      result.dispose();
-      if (!element)
-        return null;
-      if ((options as any).__testHookBeforeAdoptNode)
-        await progress.race((options as any).__testHookBeforeAdoptNode());
-      try {
-        const mainContext = await progress.race(resolved.frame._mainContext());
-        return await progress.race(element._adoptTo(mainContext));
-      } catch (e) {
-        return continuePolling;
-      }
-    });
-    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+          if ((options as any).visibility)
+            throw new Error('options.visibility is not supported, did you mean options.state?');
+          if ((options as any).waitFor && (options as any).waitFor !== 'visible')
+            throw new Error('options.waitFor is not supported, did you mean options.state?');
+          const { state = 'visible' } = options;
+          if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
+            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
+          if (performActionPreChecksAndLog)
+            progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);
+
+          const promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, true, async handle => {
+            const attached = !!handle;
+            var visible = false;
+            if (attached) {
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                visible = await handle.parentNode.evaluateInUtility(([injected, node, { handle }]) => {
+                  return handle ? injected.utils.isElementVisible(handle) : false;
+                }, { handle });
+              } else {
+                visible = await handle.parentNode.evaluate((injected, { handle }) => {
+                  return handle ? injected.utils.isElementVisible(handle) : false;
+                }, { handle });
+              }
+            }
+
+            const success = {
+              attached,
+              detached: !attached,
+              visible,
+              hidden: !visible
+            }[state];
+            if (!success) return "internal:continuepolling";
+            if (options.omitReturnValue) return null;
+
+            const element = state === 'attached' || state === 'visible' ? handle : null;
+            if (!element) return null;
+            if (options.__testHookBeforeAdoptNode) await options.__testHookBeforeAdoptNode();
+            try {
+              return element;
+            } catch (e) {
+              return "internal:continuepolling";
+            }
+          }, "returnOnNotResolved");
+
+          return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+        
   }
 
   async dispatchEvent(progress: Progress, selector: string, type: string, eventInit: Object = {}, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<void> {
@@ -832,18 +890,27 @@
 
   async evalOnSelector(selector: string, strict: boolean, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {
     const handle = await this.selectors.query(selector, { strict }, scope);
-    if (!handle)
-      throw new Error(`Failed to find element matching selector "${selector}"`);
-    const result = await handle.evaluateExpression(expression, { isFunction }, arg);
-    handle.dispose();
-    return result;
+            if (!handle)
+              throw new Error('Failed to find element matching selector "' + selector + '"');
+            const result = await handle.evaluateExpression(expression, { isFunction }, arg, true);
+            handle.dispose();
+            return result;
   }
 
-  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {
-    const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope);
-    const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg);
-    arrayHandle.dispose();
-    return result;
+  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle, isolatedContext?: boolean): Promise<any> {
+
+          try {
+            isolatedContext = this.selectors._parseSelector(selector, { strict: false }).world !== "main" && isolatedContext;
+            const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope, isolatedContext);
+            const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg, isolatedContext);
+            arrayHandle.dispose();
+            return result;
+          } catch (e) {
+            // Do i look like i know whats going on here?
+            if ("JSHandles can be evaluated only in the context they were created!" === e.message) return await this.evalOnSelectorAll(selector, expression, isFunction, arg, scope, isolatedContext);
+            throw e;
+          }
+        
   }
 
   async maskSelectors(selectors: ParsedSelector[], color: string): Promise<void> {
@@ -855,17 +922,35 @@
   }
 
   async querySelectorAll(selector: string): Promise<dom.ElementHandle<Element>[]> {
-    return this.selectors.queryAll(selector);
+
+          const metadata = { internal: false, log: [], method: "querySelectorAll" };
+          const progress = {
+            log: message => metadata.log.push(message),
+            metadata,
+            race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+          }
+          return await this._retryWithoutProgress(progress, selector, null, false, async (result) => {
+            if (!result || !result[0]) return [];
+            return result[1];
+          }, 'returnAll', null);
+        
   }
 
   async queryCount(selector: string, options: any): Promise<number> {
-    try {
-      return await this.selectors.queryCount(selector, options);
-    } catch (e) {
-      if (this.isNonRetriableError(e))
-        throw e;
-      return 0;
-    }
+
+          const metadata = { internal: false, log: [], method: "queryCount" };
+          const progress = {
+            log: message => metadata.log.push(message),
+            metadata,
+            race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+          }
+          return await this._retryWithoutProgress(progress, selector, null, false, async (result) => {
+            if (!result) return 0;
+            const handle = result[0];
+            const handles = result[1];
+            return handle ? handles.length : 0;
+          }, 'returnAll', null);
+        
   }
 
   async content(): Promise<string> {
@@ -887,29 +972,23 @@
   }
 
   async setContent(progress: Progress, html: string, options: types.NavigateOptions): Promise<void> {
-    const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
-    await this.raceNavigationAction(progress, async () => {
-      const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
-      progress.log(`setting frame content, waiting until "${waitUntil}"`);
-      const context = await progress.race(this._utilityContext());
-      const tagPromise = new ManualPromise<void>();
-      this._page.frameManager._consoleMessageTags.set(tag, () => {
-        // Clear lifecycle right after document.open() - see 'tag' below.
-        this._onClearLifecycle();
-        tagPromise.resolve();
-      });
-      const lifecyclePromise = progress.race(tagPromise).then(() => this.waitForLoadState(progress, waitUntil));
-      const contentPromise = progress.race(context.evaluate(({ html, tag }) => {
-        document.open();
-        console.debug(tag);  // eslint-disable-line no-console
-        document.write(html);
-        document.close();
-      }, { html, tag }));
-      await Promise.all([contentPromise, lifecyclePromise]);
-      return null;
-    }).finally(() => {
-      this._page.frameManager._consoleMessageTags.delete(tag);
-    });
+
+          await this.raceNavigationAction(progress, async () => {
+            const waitUntil = options.waitUntil === void 0 ? "load" : options.waitUntil;
+            progress.log(`setting frame content, waiting until "${waitUntil}"`);
+            const lifecyclePromise = new Promise((resolve, reject) => {
+              this._onClearLifecycle();
+              this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
+            });
+            const setContentPromise = this._page.delegate._mainFrameSession._client.send("Page.setDocumentContent", {
+              frameId: this._id,
+              html
+            });
+            await Promise.all([setContentPromise, lifecyclePromise]);
+
+            return null;
+          });
+        
   }
 
   name(): string {
@@ -1101,60 +1180,13 @@
     progress: Progress,
     selector: string,
     options: { strict?: boolean, noAutoWaiting?: boolean, force?: boolean, performActionPreChecks?: boolean },
-    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>): Promise<R> {
-    progress.log(`waiting for ${this._asLocator(selector)}`);
-    const noAutoWaiting = (options as any).__testHookNoAutoWaiting ?? options.noAutoWaiting;
-    const performActionPreChecks = (options.performActionPreChecks ?? !options.force) && !noAutoWaiting;
-    return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecks)
-        await this._page.performActionPreChecks(progress);
+    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>, returnAction: boolean | undefined): Promise<R> {
 
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, { strict: options.strict }));
-      if (!resolved) {
-        if (noAutoWaiting)
-          throw new dom.NonRecoverableDOMError('Element(s) not found');
-        return continuePolling;
-      }
-      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, callId }) => {
-        const elements = injected.querySelectorAll(info.parsed, document);
-        if (callId)
-          injected.markTargetElements(new Set(elements), callId);
-        const element = elements[0] as Element | undefined;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${injected.previewNode(element)}`;
-        }
-        injected.checkDeprecatedSelectorUsage(info.parsed, elements);
-        return { log, success: !!element, element };
-      }, { info: resolved.info, callId: progress.metadata.id }));
-      const { log, success } = await progress.race(result.evaluate(r => ({ log: r.log, success: r.success })));
-      if (log)
-        progress.log(log);
-      if (!success) {
-        if (noAutoWaiting)
-          throw new dom.NonRecoverableDOMError('Element(s) not found');
-        result.dispose();
-        return continuePolling;
-      }
-      const element = await progress.race(result.evaluateHandle(r => r.element)) as dom.ElementHandle<Element>;
-      result.dispose();
-      try {
-        const result = await action(element);
-        if (result === 'error:notconnected') {
-          if (noAutoWaiting)
-            throw new dom.NonRecoverableDOMError('Element is not attached to the DOM');
-          progress.log('element was detached from the DOM, retrying');
-          return continuePolling;
-        }
-        return result;
-      } finally {
-        element?.dispose();
-      }
-    });
+          progress.log("waiting for " + this._asLocator(selector));
+          return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
+            return this._retryWithoutProgress(progress, selector, strict, performActionPreChecks, action, returnAction, continuePolling);
+          });
+        
   }
 
   async rafrafTimeoutScreenshotElementWithProgress(progress: Progress, selector: string, timeout: number, options: ScreenshotOptions): Promise<Buffer> {
@@ -1307,20 +1339,61 @@
   }
 
   async isVisibleInternal(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
-    try {
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved)
-        return false;
-      return await progress.race(resolved.injected.evaluate((injected, { info, root }) => {
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        const state = element ? injected.elementState(element, 'visible') : { matches: false, received: 'error:notconnected' };
-        return state.matches;
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));
-    } catch (e) {
-      if (this.isNonRetriableError(e))
-        throw e;
-      return false;
-    }
+
+          try {
+            const metadata = { internal: false, log: [], method: "isVisible" };
+            const progress = {
+              log: message => metadata.log.push(message),
+              metadata,
+              race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+            }
+            progress.log("waiting for " + this._asLocator(selector));
+            if (selector === ":scope") {
+              const scopeParentNode = scope.parentNode || scope;
+              if (scopeParentNode.constructor.name == "ElementHandle") {
+                return await scopeParentNode.evaluateInUtility(([injected, node, { scope: handle2 }]) => {
+                  const state = handle2 ? injected.elementState(handle2, "visible") : {
+                    matches: false,
+                    received: "error:notconnected"
+                  };
+                  return state.matches;
+                }, { scope });
+              } else {
+                return await scopeParentNode.evaluate((injected, node, { scope: handle2 }) => {
+                  const state = handle2 ? injected.elementState(handle2, "visible") : {
+                    matches: false,
+                    received: "error:notconnected"
+                  };
+                  return state.matches;
+                }, { scope });
+              }
+            } else {
+              return await this._retryWithoutProgress(progress, selector, options.strict, false, async (handle) => {
+                if (!handle) return false;
+                if (handle.parentNode.constructor.name == "ElementHandle") {
+                  return await handle.parentNode.evaluateInUtility(([injected, node, { handle: handle2 }]) => {
+                    const state = handle2 ? injected.elementState(handle2, "visible") : {
+                      matches: false,
+                      received: "error:notconnected"
+                    };
+                    return state.matches;
+                  }, { handle });
+                } else {
+                  return await handle.parentNode.evaluate((injected, { handle: handle2 }) => {
+                    const state = handle2 ? injected.elementState(handle2, "visible") : {
+                      matches: false,
+                      received: "error:notconnected"
+                    };
+                    return state.matches;
+                  }, { handle });
+                }
+              }, "returnOnNotResolved", null);
+            }
+          } catch (e) {
+            if (this.isNonRetriableError(e)) throw e;
+            return false;
+          }
+        
   }
 
   async isHidden(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
@@ -1443,47 +1516,76 @@
   }
 
   private async _expectInternal(progress: Progress, selector: string | undefined, options: FrameExpectParams, lastIntermediateResult: { received?: any, isSet: boolean, errorMessage?: string }, noAbort: boolean) {
-    // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.
-    const race = <T>(p: Promise<T>) => noAbort ? p : progress.race(p);
-    const selectorInFrame = selector ? await race(this.selectors.resolveFrameForSelector(selector, { strict: true })) : undefined;
 
-    const { frame, info } = selectorInFrame || { frame: this, info: undefined };
-    const world = options.expression === 'to.have.property' ? 'main' : (info?.world ?? 'utility');
-    const context = await race(frame._context(world));
-    const injected = await race(context.injectedScript());
+          // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.
+          const race = (p) => noAbort ? p : progress.race(p);
+          const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
+          var log, matches, received, missingReceived;
+          if (selector) {
+            const { frame, info } = await race(this.selectors.resolveFrameForSelector(selector, { strict: true }));
+            const action = async result => {
+              if (!result) {
+                if (options.expectedNumber === 0)
+                  return { matches: true };
+                // expect(locator).toBeHidden() passes when there is no element.
+                if (!options.isNot && options.expression === 'to.be.hidden')
+                  return { matches: true };
+                // expect(locator).not.toBeVisible() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.visible')
+                  return { matches: false };
+                // expect(locator).toBeAttached({ attached: false }) passes when there is no element.
+                if (!options.isNot && options.expression === 'to.be.detached')
+                  return { matches: true };
+                // expect(locator).not.toBeAttached() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.attached')
+                  return { matches: false };
+                // expect(locator).not.toBeInViewport() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.in.viewport')
+                  return { matches: false };
+                // When none of the above applies, expect does not match.
+                return { matches: options.isNot, missingReceived: true };
+              }
 
-    const { log, matches, received, missingReceived } = await race(injected.evaluate(async (injected, { info, options, callId }) => {
-      const elements = info ? injected.querySelectorAll(info.parsed, document) : [];
-      if (callId)
-        injected.markTargetElements(new Set(elements), callId);
-      const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
-      let log = '';
-      if (isArray)
-        log = `  locator resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`;
-      else if (elements.length > 1)
-        throw injected.strictModeViolationError(info!.parsed, elements);
-      else if (elements.length)
-        log = `  locator resolved to ${injected.previewNode(elements[0])}`;
-      if (info)
-        injected.checkDeprecatedSelectorUsage(info.parsed, elements);
-      return { log, ...await injected.expect(elements[0], options, elements) };
-    }, { info, options, callId: progress.metadata.id }));
+              const handle = result[0];
+              const handles = result[1];
 
-    if (log)
-      progress.log(log);
-    // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
-    if (matches === options.isNot) {
-      if (missingReceived) {
-        lastIntermediateResult.errorMessage = 'Error: element(s) not found';
-      } else {
-        lastIntermediateResult.errorMessage = undefined;
-        lastIntermediateResult.received = received;
-      }
-      lastIntermediateResult.isSet = true;
-      if (!missingReceived && !Array.isArray(received))
-        progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
-    }
-    return { matches, received };
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                return await handle.parentNode.evaluateInUtility(async ([injected, node, { handle, options, handles }]) => {
+                  return await injected.expect(handle, options, handles);
+                }, { handle, options, handles });
+              } else {
+                return await handle.parentNode.evaluate(async (injected, { handle, options, handles }) => {
+                  return await injected.expect(handle, options, handles);
+                }, { handle, options, handles });
+              }
+            }
+
+            if (noAbort) {
+              var { log, matches, received, missingReceived } = await this._retryWithoutProgress(progress, selector, !isArray, false, action, 'returnAll', null);
+            } else {
+              var { log, matches, received, missingReceived } = await race(this._retryWithProgressIfNotConnected(progress, selector, !isArray, false, action, 'returnAll'));
+            }
+          } else {
+            const world = options.expression === 'to.have.property' ? 'main' : 'utility';
+            const context = await race(this._context(world));
+            const injected = await race(context.injectedScript());
+            var { matches, received, missingReceived } = await race(injected.evaluate(async (injected, { options, callId }) => {
+              return { ...await injected.expect(undefined, options, []) };
+            }, { options, callId: progress.metadata.id }));
+          }
+
+
+          if (log)
+            progress.log(log);
+          // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
+          if (matches === options.isNot) {
+            lastIntermediateResult.received = missingReceived ? '<element(s) not found>' : received;
+            lastIntermediateResult.isSet = true;
+            if (!missingReceived && !Array.isArray(received))
+              progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
+          }
+          return { matches, received };
+        
   }
 
   async waitForFunctionExpression<R>(progress: Progress, expression: string, isFunction: boolean | undefined, arg: any, options: { pollingInterval?: number }, world: types.World = 'main'): Promise<js.SmartHandle<R>> {
@@ -1599,29 +1701,71 @@
   }
 
   private async _callOnElementOnceMatches<T, R>(progress: Progress, selector: string, body: ElementCallback<T, R>, taskData: T, options: types.StrictOptions & { mainWorld?: boolean }, scope?: dom.ElementHandle): Promise<R> {
-    const callbackText = body.toString();
-    progress.log(`waiting for ${this._asLocator(selector)}`);
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved)
-        return continuePolling;
-      const { log, success, value } = await progress.race(resolved.injected.evaluate((injected, { info, callbackText, taskData, callId, root }) => {
-        const callback = injected.eval(callbackText) as ElementCallback<T, R>;
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        if (!element)
-          return { success: false };
-        const log = `  locator resolved to ${injected.previewNode(element)}`;
-        if (callId)
-          injected.markTargetElements(new Set([element]), callId);
-        return { log, success: true, value: callback(injected, element, taskData as T) };
-      }, { info: resolved.info, callbackText, taskData, callId: progress.metadata.id, root: resolved.frame === this ? scope : undefined }));
-      if (log)
-        progress.log(log);
-      if (!success)
-        return continuePolling;
-      return value!;
-    });
-    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+
+          const callbackText = body.toString();
+          progress.log("waiting for "+ this._asLocator(selector));
+          var promise;
+          if (selector === ":scope") {
+            const scopeParentNode = scope.parentNode || scope;
+            if (scopeParentNode.constructor.name == "ElementHandle") {
+              promise = scopeParentNode.evaluateInUtility(([injected, node, { callbackText: callbackText2, scope: handle2, taskData: taskData2 }]) => {
+                const callback = injected.eval(callbackText2);
+                return callback(injected, handle2, taskData2);
+              }, {
+                callbackText,
+                scope,
+                taskData
+              });
+            } else {
+              promise = scopeParentNode.evaluate((injected, { callbackText: callbackText2, scope: handle2, taskData: taskData2 }) => {
+                const callback = injected.eval(callbackText2);
+                return callback(injected, handle2, taskData2);
+              }, {
+                callbackText,
+                scope,
+                taskData
+              });
+            }
+          } else {
+            promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, false, async (handle) => {
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                // Handling dispatch_event's in isolated and Main Contexts
+                const [taskScope] = Object.values(taskData?.eventInit ?? {});
+                if (taskScope) {
+                  const taskScopeContext = taskScope._context;
+                  const adoptedHandle = await handle._adoptTo(taskScopeContext);
+                  return await taskScopeContext.evaluate(([injected, node, { callbackText: callbackText2, adoptedHandle: handle2, taskData: taskData2 }]) => {
+                    const callback = injected.eval(callbackText2);
+                    return callback(injected, handle2, taskData2);
+                  }, [
+                    await taskScopeContext.injectedScript(),
+                    adoptedHandle,
+                    { callbackText, adoptedHandle, taskData },
+                  ]);
+                }
+
+                return await handle.parentNode.evaluateInUtility(([injected, node, { callbackText: callbackText2, handle: handle2, taskData: taskData2 }]) => {
+                  const callback = injected.eval(callbackText2);
+                  return callback(injected, handle2, taskData2);
+                }, {
+                  callbackText,
+                  handle,
+                  taskData
+                });
+              } else {
+                return await handle.parentNode.evaluate((injected, { callbackText: callbackText2, handle: handle2, taskData: taskData2 }) => {
+                  const callback = injected.eval(callbackText2);
+                  return callback(injected, handle2, taskData2);
+                }, {
+                  callbackText,
+                  handle,
+                  taskData
+                });
+              }
+            })
+          }
+          return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+        
   }
 
   private _setContext(world: types.World, context: dom.FrameExecutionContext | null) {
@@ -1688,6 +1832,257 @@
   private _asLocator(selector: string) {
     return asLocator(this._page.browserContext._browser.sdkLanguage(), selector);
   }
+
+  _isolatedWorld: dom.FrameExecutionContext;
+  _mainWorld: dom.FrameExecutionContext;
+  _iframeWorld: dom.FrameExecutionContext;
+
+  async _getFrameMainFrameContextId(client): Promise<number> {
+
+          try {
+            var globalDocument = await client._sendMayFail("DOM.getFrameOwner", {frameId: this._id,});
+            if (globalDocument && globalDocument.nodeId) {
+              var describedNode = await client._sendMayFail("DOM.describeNode", {
+                backendNodeId: globalDocument.backendNodeId,
+              });
+              if (describedNode) {
+                var resolvedNode = await client._sendMayFail("DOM.resolveNode", {
+                  nodeId: describedNode.node.contentDocument.nodeId,
+                });
+                var _executionContextId = parseInt(resolvedNode.object.objectId.split(".")[1], 10);
+                return _executionContextId;
+              }
+            }
+          } catch (e) {}
+          return 0;
+        
+  }
+
+  async _retryWithoutProgress(progress, selector, strict, performActionPreChecks, action, returnAction, continuePolling) {
+
+          if (performActionPreChecks) await this._page.performActionPreChecks(progress);
+          const resolved = await this.selectors.resolveInjectedForSelector(selector, { strict });
+          if (!resolved) {
+            if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') {
+              const result = await action(null);
+              return result === "internal:continuepolling" ? continuePolling : result;
+            }
+            return continuePolling;
+          }
+
+          try {
+            var client = this._page.delegate._sessionForFrame(resolved.frame)._client;
+          } catch (e) {
+            var client = this._page.delegate._mainFrameSession._client;
+          }
+          var utilityContext = await resolved.frame._utilityContext();
+          var mainContext = await resolved.frame._mainContext();
+          const documentNode = await client._sendMayFail('Runtime.evaluate', {
+            expression: "document",
+            serializationOptions: {
+              serialization: "idOnly"
+            },
+            contextId: utilityContext.delegate._contextId,
+          });
+          if (!documentNode) return continuePolling;
+          const documentScope = new dom.ElementHandle(utilityContext, documentNode.result.objectId);
+
+          let currentScopingElements;
+          try {
+            currentScopingElements = await this._customFindElementsByParsed(resolved, client, mainContext, documentScope, progress, resolved.info.parsed);
+          } catch (e) {
+            if ("JSHandles can be evaluated only in the context they were created!" === e.message) return continuePolling3;
+            await progress.race(resolved.injected.evaluateHandle((injected, { error }) => { throw error }, { error: e }));
+          }
+
+          if (currentScopingElements.length == 0) {
+            // TODO: Dispose?
+            if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') {
+            const result = await action(null);
+            return result === "internal:continuepolling" ? continuePolling2 : result;
+          }
+            return continuePolling;
+          }
+          const resultElement = currentScopingElements[0];
+          if (currentScopingElements.length > 1) {
+            if (resolved.info.strict) {
+              await progress.race(resolved.injected.evaluateHandle((injected, {
+                info,
+                elements
+              }) => {
+                throw injected.strictModeViolationError(info.parsed, elements);
+              }, {
+                info: resolved.info,
+                elements: currentScopingElements
+              }));
+            }
+            progress.log("  locator resolved to " + currentScopingElements.length + " elements. Proceeding with the first one: " + resultElement.preview());
+          } else if (resultElement) {
+            progress.log("  locator resolved to " + resultElement.preview());
+          }
+
+          try {
+            var result = null;
+            if (returnAction === 'returnAll') {
+              result = await action([resultElement, currentScopingElements]);
+            } else {
+              result = await action(resultElement);
+            }
+            if (result === 'error:notconnected') {
+              progress.log('element was detached from the DOM, retrying');
+              return continuePolling;
+            } else if (result === 'internal:continuepolling') {
+              return continuePolling;
+            }
+            return result;
+          } finally {}
+        
+  }
+
+  async _customFindElementsByParsed(resolved, client, context, documentScope, progress, parsed) {
+
+          var parsedEdits = { ...parsed };
+          // Note: We start scoping at document level
+          var currentScopingElements = [documentScope];
+          while (parsed.parts.length > 0) {
+            var part = parsed.parts.shift();
+            parsedEdits.parts = [part];
+            // Getting All Elements
+            var elements = [];
+            var elementsIndexes = [];
+
+            if (part.name == "nth") {
+              const partNth = Number(part.body);
+              // Check if any Elements are currently scoped, else return empty array to continue polling
+              if (currentScopingElements.length == 0) return [];
+              // Check if the partNth is within the bounds of currentScopingElements
+              if (partNth > currentScopingElements.length-1 || partNth < -(currentScopingElements.length-1)) {
+                if (parsed.capture !== undefined) throw new Error("Can't query n-th element in a request with the capture.");
+                return [];
+              } else {
+                currentScopingElements = [currentScopingElements.at(partNth)];
+                continue;
+              }
+            } else if (part.name == "internal:or") {
+              var orredElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+              elements = currentScopingElements.concat(orredElements);
+            } else if (part.name == "internal:and") {
+              var andedElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+              const backendNodeIds = new Set(andedElements.map(item => item.backendNodeId));
+              elements = currentScopingElements.filter(item => backendNodeIds.has(item.backendNodeId));
+            } else {
+              for (const scope of currentScopingElements) {
+                const describedScope = await client.send('DOM.describeNode', {
+                  objectId: scope._objectId,
+                  depth: -1,
+                  pierce: true
+                });
+
+                // Elements Queryed in the "current round"
+                var queryingElements = [];
+                function findClosedShadowRoots(node, results = []) {
+                  if (!node || typeof node !== 'object') return results;
+                  if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                    for (const shadowRoot of node.shadowRoots) {
+                      if (shadowRoot.shadowRootType === 'closed' && shadowRoot.backendNodeId) {
+                        results.push(shadowRoot.backendNodeId);
+                      }
+                      findClosedShadowRoots(shadowRoot, results);
+                    }
+                  }
+                  if (node.nodeName !== 'IFRAME' && node.children && Array.isArray(node.children)) {
+                    for (const child of node.children) {
+                      findClosedShadowRoots(child, results);
+                    }
+                  }
+                  return results;
+                }
+
+                var shadowRootBackendIds = findClosedShadowRoots(describedScope.node);
+                var shadowRoots = [];
+                for (var shadowRootBackendId of shadowRootBackendIds) {
+                  var resolvedShadowRoot = await client.send('DOM.resolveNode', {
+                    backendNodeId: shadowRootBackendId,
+                    contextId: context.delegate._contextId
+                  });
+                  shadowRoots.push(new dom.ElementHandle(context, resolvedShadowRoot.object.objectId));
+                }
+
+                for (var shadowRoot of shadowRoots) {
+                  const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                   const elements = injected.querySelectorAll(parsed, node);
+                    if (callId) injected.markTargetElements(new Set(elements), callId);
+                    return elements
+                  }, {
+                    parsed: parsedEdits,
+                    callId: progress.metadata.id
+                  });
+
+                  const shadowElementsAmount = await shadowElements.getProperty("length");
+                  queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+                }
+
+                // Document Root Elements (not in CSR)
+                const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                  const elements = injected.querySelectorAll(parsed, node);
+                  if (callId) injected.markTargetElements(new Set(elements), callId);
+                  return elements
+                }, {
+                  parsed: parsedEdits,
+                  callId: progress.metadata.id
+                });
+                const rootElementsAmount = await rootElements.getProperty("length");
+                queryingElements.push([rootElements, rootElementsAmount, scope]);
+
+                // Querying and Sorting the elements by their backendNodeId
+                for (var queryedElement of queryingElements) {
+                  var elementsToCheck = queryedElement[0];
+                  var elementsAmount = await queryedElement[1].jsonValue();
+                  var parentNode = queryedElement[2];
+                  for (var i = 0; i < elementsAmount; i++) {
+                    if (parentNode.constructor.name == "ElementHandle") {
+                      var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck }]) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+                    } else {
+                      var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck }) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+                    }
+                    // For other Functions/Utilities
+                    elementToCheck.parentNode = parentNode;
+                    var resolvedElement = await client.send('DOM.describeNode', {
+                      objectId: elementToCheck._objectId,
+                      depth: -1,
+                    });
+                    // Note: Possible Bug, Maybe well actually have to check the Documents Node Position instead of using the backendNodeId
+                    elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+                    elementToCheck.nodePosition = this.selectors._findElementPositionInDomTree(elementToCheck, describedScope.node, context, "");
+                    elements.push(elementToCheck);
+                  }
+                }
+              }
+            }
+
+            // Sorting elements by their nodePosition, which is a index to the Element in the DOM tree
+            const getParts = (pos) => (pos || '').split('.').filter(Boolean).map(Number);
+            elements.sort((a, b) => {
+              const partA = getParts(a.nodePosition);
+              const partB = getParts(b.nodePosition);
+              const maxLength = Math.max(partA.length, partB.length);
+
+              for (let i = 0; i < maxLength; i++) {
+                const aVal = partA[i] ?? -1;
+                const bVal = partB[i] ?? -1;
+                if (aVal !== bVal) return aVal - bVal;
+              }
+              return 0;
+            });
+
+            // Remove duplicates by backendNodeId, keeping the first occurrence
+            currentScopingElements = Array.from(
+              new Map(elements.map((e) => [e.backendNodeId, e])).values()
+            );
+          }
+          return currentScopingElements;
+        
+  }
 }
 
 class SignalBarrier {
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/javascript.ts patchright/node_modules/playwright-core/src/server/javascript.ts
---
+++
@@ -149,17 +149,37 @@
     return evaluate(this._context, false /* returnByValue */, pageFunction, this, arg);
   }
 
-  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any) {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: true }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean) {
 
-  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any): Promise<JSHandle<any>> {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: false }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+          let context = this._context;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = context.frame;
+              if (frame) {
+                  if (isolatedContext === true) context = await frame._utilityContext();
+                  else if (isolatedContext === false) context = await frame._mainContext();
+              }
+          }
+        
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: true }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
+
+  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean): Promise<JSHandle<any>> {
+
+          let context = this._context;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = this._context.frame;
+              if (frame) {
+                  if (isolatedContext === true) context = await frame._utilityContext();
+                  else if (isolatedContext === false) context = await frame._mainContext();
+              }
+          }
+        
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: false }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
 
   async getProperty(propertyName: string): Promise<JSHandle> {
     const objectHandle = await this.evaluateHandle((object: any, propertyName) => {
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/page.ts patchright/node_modules/playwright-core/src/server/page.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import { createPageBindingScript, deliverBindingResult, takeBindingHandle } from './pageBinding';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -324,30 +326,25 @@
   }
 
   async exposeBinding(progress: Progress, name: string, needsHandle: boolean, playwrightBinding: frames.FunctionWithSource): Promise<PageBinding> {
-    if (this._pageBindings.has(name))
-      throw new Error(`Function "${name}" has been already registered`);
-    if (this.browserContext._pageBindings.has(name))
-      throw new Error(`Function "${name}" has been already registered in the browser context`);
-    await progress.race(this.browserContext.exposePlaywrightBindingIfNeeded());
-    const binding = new PageBinding(name, playwrightBinding, needsHandle);
-    this._pageBindings.set(name, binding);
-    try {
-      await progress.race(this.delegate.addInitScript(binding.initScript));
-      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));
-      return binding;
-    } catch (error) {
-      this._pageBindings.delete(name);
-      throw error;
-    }
+
+          if (this._pageBindings.has(name))
+            throw new Error(`Function "${name}" has been already registered`);
+          if (this.browserContext._pageBindings.has(name))
+            throw new Error(`Function "${name}" has been already registered in the browser context`);
+          const binding = new PageBinding(name, playwrightBinding, needsHandle);
+          this._pageBindings.set(name, binding);
+          await this.delegate.exposeBinding(binding);
+        
   }
 
   async removeExposedBindings(bindings: PageBinding[]) {
-    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);
-    for (const binding of bindings)
-      this._pageBindings.delete(binding.name);
-    await this.delegate.removeInitScripts(bindings.map(binding => binding.initScript));
-    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\n`).join('');
-    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');
+
+          for (const key of this._pageBindings.keys()) {
+            if (!key.startsWith('__pw'))
+              this._pageBindings.delete(key);
+          }
+          await this.delegate.removeExposedBindings();
+        
   }
 
   async setExtraHTTPHeaders(progress: Progress, headers: types.HeadersArray) {
@@ -633,9 +630,10 @@
   }
 
   async removeInitScripts(initScripts: InitScript[]) {
-    const set = new Set(initScripts);
-    this.initScripts = this.initScripts.filter(script => !set.has(script));
-    await this.delegate.removeInitScripts(initScripts);
+
+          this.initScripts.splice(0, this.initScripts.length);
+          await this.delegate.removeInitScripts();
+        
   }
 
   needsRequestInterception(): boolean {
@@ -837,13 +835,6 @@
       this.browserContext.addVisitedOrigin(origin);
   }
 
-  allInitScripts() {
-    const bindings = [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()].map(binding => binding.initScript);
-    if (this.browserContext.bindingsInitScript)
-      bindings.unshift(this.browserContext.bindingsInitScript);
-    return [...bindings, ...this.browserContext.initScripts, ...this.initScripts];
-  }
-
   getBinding(name: string) {
     return this._pageBindings.get(name) || this.browserContext._pageBindings.get(name);
   }
@@ -867,6 +858,12 @@
     const snapshot = await snapshotFrameForAI(progress, this.mainFrame(), options);
     return { full: snapshot.full.join('\n'), incremental: snapshot.incremental?.join('\n') };
   }
+
+  allBindings() {
+
+          return [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()];
+        
+  }
 }
 
 export const WorkerEvent = {
@@ -911,77 +908,82 @@
     this.openScope.close(new Error('Worker closed'));
   }
 
-  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction }, arg);
-  }
+  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
 
-  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction }, arg);
-  }
-}
+          let context = await this._executionContextPromise;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      return js.evaluateExpression(context, expression, { returnByValue: true, isFunction }, arg);
+    }
 
-export class PageBinding {
-  private static kController = '__playwright__binding__controller__';
-  static kBindingName = '__playwright__binding__';
+  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
 
-  static createInitScript() {
-    return new InitScript(`
-      (() => {
-        const module = {};
-        ${rawBindingsControllerSource.source}
-        const property = '${PageBinding.kController}';
-        if (!globalThis[property])
-          globalThis[property] = new (module.exports.BindingsController())(globalThis, '${PageBinding.kBindingName}');
-      })();
-    `);
-  }
+          let context = await this._executionContextPromise;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = this._context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      return js.evaluateExpression(context, expression, { returnByValue: false, isFunction }, arg);
+    }
+}
 
-  readonly name: string;
-  readonly playwrightFunction: frames.FunctionWithSource;
-  readonly initScript: InitScript;
-  readonly needsHandle: boolean;
-  readonly cleanupScript: string;
-  forClient?: unknown;
 
-  constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
-    this.name = name;
-    this.playwrightFunction = playwrightFunction;
-    this.initScript = new InitScript(`globalThis['${PageBinding.kController}'].addBinding(${JSON.stringify(name)}, ${needsHandle})`);
-    this.needsHandle = needsHandle;
-    this.cleanupScript = `globalThis['${PageBinding.kController}'].removeBinding(${JSON.stringify(name)})`;
-  }
+      export class PageBinding {
+        readonly source: string;
+        readonly name: string;
+        readonly playwrightFunction: frames.FunctionWithSource;
+        readonly needsHandle: boolean;
+        readonly internal: boolean;
 
-  static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
-    const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;
-    try {
-      assert(context.world);
-      const binding = page.getBinding(name);
-      if (!binding)
-        throw new Error(`Function "${name}" is not exposed`);
-      let result: any;
-      if (binding.needsHandle) {
-        const handle = await context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].takeBindingHandle(arg)`, { isFunction: true }, { name, seq }).catch(e => null);
-        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, handle);
-      } else {
-        if (!Array.isArray(serializedArgs))
-          throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
-        const args = serializedArgs!.map(a => parseEvaluationResultValue(a));
-        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, ...args);
+        constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
+          this.name = name;
+          this.playwrightFunction = playwrightFunction;
+          this.source = createPageBindingScript(name, needsHandle);
+          this.needsHandle = needsHandle;
+        }
+
+        static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
+          const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;
+          try {
+            assert(context.world);
+            const binding = page.getBinding(name);
+            if (!binding)
+              throw new Error(`Function "${name}" is not exposed`);
+            let result: any;
+            if (binding.needsHandle) {
+              const handle = await context.evaluateHandle(takeBindingHandle, { name, seq }).catch(e => null);
+              result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, handle);
+            } else {
+              if (!Array.isArray(serializedArgs))
+                throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
+              const args = serializedArgs!.map(a => parseEvaluationResultValue(a));
+              result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, ...args);
+            }
+            context.evaluate(deliverBindingResult, { name, seq, result }).catch(e => debugLogger.log('error', e));
+          } catch (error) {
+            context.evaluate(deliverBindingResult, { name, seq, error }).catch(e => debugLogger.log('error', e));
+          }
+        }
       }
-      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, result }).catch(e => debugLogger.log('error', e));
-    } catch (error) {
-      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, error }).catch(e => debugLogger.log('error', e));
-    }
-  }
-}
+    
 
 export class InitScript {
   readonly source: string;
 
   constructor(source: string) {
-    this.source = `(() => {
-      ${source}
-    })();`;
+    
+            this.source = `(() => { ${source} })();`;
+          
   }
 }
 
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/pageBinding.ts patchright/node_modules/playwright-core/src/server/pageBinding.ts
---
+++
@@ -0,0 +1,91 @@
+
+      /**
+       * Copyright (c) Microsoft Corporation.
+       *
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       *
+       * http://www.apache.org/licenses/LICENSE-2.0
+       *
+       * Unless required by applicable law or agreed to in writing, software
+       * distributed under the License is distributed on an "AS IS" BASIS,
+       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+       * See the License for the specific language governing permissions and
+       * limitations under the License.
+       */
+      import { source } from '../utils/isomorphic/oldUtilityScriptSerializers';
+
+      import type { SerializedValue } from '../utils/isomorphic/oldUtilityScriptSerializers';
+
+      export type BindingPayload = {
+        name: string;
+        seq: number;
+        serializedArgs?: SerializedValue[],
+      };
+
+      function addPageBinding(bindingName: string, needsHandle: boolean, utilityScriptSerializersFactory: typeof source) {
+        const { serializeAsCallArgument } = utilityScriptSerializersFactory;
+        // eslint-disable-next-line no-restricted-globals
+        const binding = (globalThis as any)[bindingName];
+        if (!binding || binding.toString().startsWith("(...args) => {")) return
+        // eslint-disable-next-line no-restricted-globals
+        (globalThis as any)[bindingName] = (...args: any[]) => {
+        // eslint-disable-next-line no-restricted-globals
+          const me = (globalThis as any)[bindingName];
+          if (needsHandle && args.slice(1).some(arg => arg !== undefined))
+            throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
+          let callbacks = me['callbacks'];
+          if (!callbacks) {
+            callbacks = new Map();
+            me['callbacks'] = callbacks;
+          }
+          const seq: number = (me['lastSeq'] || 0) + 1;
+          me['lastSeq'] = seq;
+          let handles = me['handles'];
+          if (!handles) {
+            handles = new Map();
+            me['handles'] = handles;
+          }
+          const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
+          let payload: BindingPayload;
+          if (needsHandle) {
+            handles.set(seq, args[0]);
+            payload = { name: bindingName, seq };
+          } else {
+            const serializedArgs = [];
+            for (let i = 0; i < args.length; i++) {
+              serializedArgs[i] = serializeAsCallArgument(args[i], v => {
+                return { fallThrough: v };
+              });
+            }
+            payload = { name: bindingName, seq, serializedArgs };
+          }
+          binding(JSON.stringify(payload));
+          return promise;
+        };
+        // eslint-disable-next-line no-restricted-globals
+      }
+
+      export function takeBindingHandle(arg: { name: string, seq: number }) {
+        // eslint-disable-next-line no-restricted-globals
+        const handles = (globalThis as any)[arg.name]['handles'];
+        const handle = handles.get(arg.seq);
+        handles.delete(arg.seq);
+        return handle;
+      }
+
+      export function deliverBindingResult(arg: { name: string, seq: number, result?: any, error?: any }) {
+        // eslint-disable-next-line no-restricted-globals
+        const callbacks = (globalThis as any)[arg.name]['callbacks'];
+        if ('error' in arg)
+          callbacks.get(arg.seq).reject(arg.error);
+        else
+          callbacks.get(arg.seq).resolve(arg.result);
+        callbacks.delete(arg.seq);
+      }
+
+      export function createPageBindingScript(name: string, needsHandle: boolean) {
+        return `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${source})())`;
+      }
+    
\ No newline at end of file
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/server/registry/index.ts patchright/node_modules/playwright-core/src/server/registry/index.ts
---
+++
@@ -1484,7 +1484,7 @@
       return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;
     default: {
       const packageManagerCommand = getPackageManagerExecCommand();
-      return `${packageManagerCommand} playwright ${parameters}`;
+      return `${packageManagerCommand} patchright ${parameters}`;
     }
   }
 }
diff -ruN -x protocol.yml --minimal playwright/node_modules/playwright-core/src/utils/isomorphic/oldUtilityScriptSerializers.ts patchright/node_modules/playwright-core/src/utils/isomorphic/oldUtilityScriptSerializers.ts
---
+++
@@ -0,0 +1,292 @@
+
+      /**
+       * Copyright (c) Microsoft Corporation.
+       *
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       *
+       * http://www.apache.org/licenses/LICENSE-2.0
+       *
+       * Unless required by applicable law or agreed to in writing, software
+       * distributed under the License is distributed on an "AS IS" BASIS,
+       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+       * See the License for the specific language governing permissions and
+       * limitations under the License.
+       */
+
+      type TypedArrayKind = 'i8' | 'ui8' | 'ui8c' | 'i16' | 'ui16' | 'i32' | 'ui32' | 'f32' | 'f64' | 'bi64' | 'bui64';
+
+      export type SerializedValue =
+          undefined | boolean | number | string |
+          { v: 'null' | 'undefined' | 'NaN' | 'Infinity' | '-Infinity' | '-0' } |
+          { d: string } |
+          { u: string } |
+          { bi: string } |
+          { e: { n: string, m: string, s: string } } |
+          { r: { p: string, f: string } } |
+          { a: SerializedValue[], id: number } |
+          { o: { k: string, v: SerializedValue }[], id: number } |
+          { ref: number } |
+          { h: number } |
+          { ta: { b: string, k: TypedArrayKind } };
+
+      type HandleOrValue = { h: number } | { fallThrough: any };
+
+      type VisitorInfo = {
+        visited: Map<object, number>;
+        lastId: number;
+      };
+
+      export function source() {
+
+        function isRegExp(obj: any): obj is RegExp {
+          try {
+            return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isDate(obj: any): obj is Date {
+          try {
+            return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isURL(obj: any): obj is URL {
+          try {
+            return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isError(obj: any): obj is Error {
+          try {
+            return obj instanceof Error || (obj && Object.getPrototypeOf(obj)?.name === 'Error');
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isTypedArray(obj: any, constructor: Function): boolean {
+          try {
+            return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;
+          } catch (error) {
+            return false;
+          }
+        }
+
+        const typedArrayConstructors: Record<TypedArrayKind, Function> = {
+          i8: Int8Array,
+          ui8: Uint8Array,
+          ui8c: Uint8ClampedArray,
+          i16: Int16Array,
+          ui16: Uint16Array,
+          i32: Int32Array,
+          ui32: Uint32Array,
+          // TODO: add Float16Array once it's in baseline
+          f32: Float32Array,
+          f64: Float64Array,
+          bi64: BigInt64Array,
+          bui64: BigUint64Array,
+        };
+
+        function typedArrayToBase64(array: any) {
+          /**
+           * Firefox does not support iterating over typed arrays, so we use `.toBase64`.
+           * Error: 'Accessing TypedArray data over Xrays is slow, and forbidden in order to encourage performant code. To copy TypedArrays across origin boundaries, consider using Components.utils.cloneInto().'
+           */
+          if ('toBase64' in array)
+            return array.toBase64();
+          const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map(b => String.fromCharCode(b)).join('');
+          return btoa(binary);
+        }
+
+        function base64ToTypedArray(base64: string, TypedArrayConstructor: any) {
+          const binary = atob(base64);
+          const bytes = new Uint8Array(binary.length);
+          for (let i = 0; i < binary.length; i++)
+            bytes[i] = binary.charCodeAt(i);
+          return new TypedArrayConstructor(bytes.buffer);
+        }
+
+        function parseEvaluationResultValue(value: SerializedValue, handles: any[] = [], refs: Map<number, object> = new Map()): any {
+          if (Object.is(value, undefined))
+            return undefined;
+          if (typeof value === 'object' && value) {
+            if ('ref' in value)
+              return refs.get(value.ref);
+            if ('v' in value) {
+              if (value.v === 'undefined')
+                return undefined;
+              if (value.v === 'null')
+                return null;
+              if (value.v === 'NaN')
+                return NaN;
+              if (value.v === 'Infinity')
+                return Infinity;
+              if (value.v === '-Infinity')
+                return -Infinity;
+              if (value.v === '-0')
+                return -0;
+              return undefined;
+            }
+            if ('d' in value)
+              return new Date(value.d);
+            if ('u' in value)
+              return new URL(value.u);
+            if ('bi' in value)
+              return BigInt(value.bi);
+            if ('e' in value) {
+              const error = new Error(value.e.m);
+              error.name = value.e.n;
+              error.stack = value.e.s;
+              return error;
+            }
+            if ('r' in value)
+              return new RegExp(value.r.p, value.r.f);
+            if ('a' in value) {
+              const result: any[] = [];
+              refs.set(value.id, result);
+              for (const a of value.a)
+                result.push(parseEvaluationResultValue(a, handles, refs));
+              return result;
+            }
+            if ('o' in value) {
+              const result: any = {};
+              refs.set(value.id, result);
+              for (const { k, v } of value.o)
+                result[k] = parseEvaluationResultValue(v, handles, refs);
+              return result;
+            }
+            if ('h' in value)
+              return handles[value.h];
+            if ('ta' in value)
+              return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);
+          }
+          return value;
+        }
+
+        function serializeAsCallArgument(value: any, handleSerializer: (value: any) => HandleOrValue): SerializedValue {
+          return serialize(value, handleSerializer, { visited: new Map(), lastId: 0 });
+        }
+
+        function serialize(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo): SerializedValue {
+          if (value && typeof value === 'object') {
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Window === 'function' && value instanceof globalThis.Window)
+              return 'ref: <Window>';
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Document === 'function' && value instanceof globalThis.Document)
+              return 'ref: <Document>';
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Node === 'function' && value instanceof globalThis.Node)
+              return 'ref: <Node>';
+          }
+          return innerSerialize(value, handleSerializer, visitorInfo);
+        }
+
+        function innerSerialize(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo): SerializedValue {
+          const result = handleSerializer(value);
+          if ('fallThrough' in result)
+            value = result.fallThrough;
+          else
+            return result;
+
+          if (typeof value === 'symbol')
+            return { v: 'undefined' };
+          if (Object.is(value, undefined))
+            return { v: 'undefined' };
+          if (Object.is(value, null))
+            return { v: 'null' };
+          if (Object.is(value, NaN))
+            return { v: 'NaN' };
+          if (Object.is(value, Infinity))
+            return { v: 'Infinity' };
+          if (Object.is(value, -Infinity))
+            return { v: '-Infinity' };
+          if (Object.is(value, -0))
+            return { v: '-0' };
+
+          if (typeof value === 'boolean')
+            return value;
+          if (typeof value === 'number')
+            return value;
+          if (typeof value === 'string')
+            return value;
+          if (typeof value === 'bigint')
+            return { bi: value.toString() };
+
+          if (isError(value)) {
+            let stack;
+            if (value.stack?.startsWith(value.name + ': ' + value.message)) {
+              // v8
+              stack = value.stack;
+            } else {
+              stack = `${value.name}: ${value.message}
+${value.stack}`;
+            }
+            return { e: { n: value.name, m: value.message, s: stack } };
+          }
+          if (isDate(value))
+            return { d: value.toJSON() };
+          if (isURL(value))
+            return { u: value.toJSON() };
+          if (isRegExp(value))
+            return { r: { p: value.source, f: value.flags } };
+          for (const [k, ctor] of Object.entries(typedArrayConstructors) as [TypedArrayKind, Function][]) {
+            if (isTypedArray(value, ctor))
+              return { ta: { b: typedArrayToBase64(value), k } };
+          }
+
+          const id = visitorInfo.visited.get(value);
+          if (id)
+            return { ref: id };
+
+          if (Array.isArray(value)) {
+            const a = [];
+            const id = ++visitorInfo.lastId;
+            visitorInfo.visited.set(value, id);
+            for (let i = 0; i < value.length; ++i)
+              a.push(serialize(value[i], handleSerializer, visitorInfo));
+            return { a, id };
+          }
+
+          if (typeof value === 'object') {
+            const o: { k: string, v: SerializedValue }[] = [];
+            const id = ++visitorInfo.lastId;
+            visitorInfo.visited.set(value, id);
+            for (const name of Object.keys(value)) {
+              let item;
+              try {
+                item = value[name];
+              } catch (e) {
+                continue;  // native bindings will throw sometimes
+              }
+              if (name === 'toJSON' && typeof item === 'function')
+                o.push({ k: name, v: { o: [], id: 0 } });
+              else
+                o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });
+            }
+
+            let jsonWrapper;
+            try {
+              // If Object.keys().length === 0 we fall back to toJSON if it exists
+              if (o.length === 0 && value.toJSON && typeof value.toJSON === 'function')
+                jsonWrapper = { value: value.toJSON() };
+            } catch (e) {
+            }
+            if (jsonWrapper)
+              return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);
+
+            return { o, id };
+          }
+        }
+
+        return { parseEvaluationResultValue, serializeAsCallArgument };
+      }
+    
\ No newline at end of file
diff -ruN -x protocol.yml --minimal playwright/node_modules/recorder/src/recorder.tsx patchright/node_modules/recorder/src/recorder.tsx
---
+++
@@ -101,7 +101,7 @@
   }, [backend, mode, selectedTab, setSelectedTab, source]);
 
   React.useEffect(() => {
-    backend.setAutoExpect({ autoExpect });
+    try { window.dispatch({ event: 'setAutoExpect', params: { autoExpect } }); } catch {}
   }, [autoExpect, backend]);
 
   React.useLayoutEffect(() => {
diff -ruN -x protocol.yml --minimal playwright/packages/injected/src/xpathSelectorEngine.ts patchright/packages/injected/src/xpathSelectorEngine.ts
---
+++
@@ -18,6 +18,43 @@
 
 export const XPathEngine: SelectorEngine = {
   queryAll(root: SelectorRoot, selector: string): Element[] {
+
+          if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
+            const result: Element[] = [];
+            // Custom ClosedShadowRoot XPath Engine
+            const parser = new DOMParser();
+            // Function to (recursively) get all elements in the shadowRoot
+            function getAllChildElements(node) {
+              const elements = [];
+              const traverse = (currentNode) => {
+                if (currentNode.nodeType === Node.ELEMENT_NODE) elements.push(currentNode);
+                currentNode.childNodes?.forEach(traverse);
+              };
+              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE) {
+                traverse(node);
+              }
+              return elements;
+            }
+            // Setting innerHTMl and childElements (all, recursive) to avoid race conditions
+            const csrHTMLContent = root.innerHTML;
+            const csrChildElements = getAllChildElements(root);
+            const htmlDoc = parser.parseFromString(csrHTMLContent, 'text/html');
+            const rootDiv = htmlDoc.body
+            const rootDivChildElements = getAllChildElements(rootDiv);
+            // Use the namespace prefix in the XPath expression
+            const it = htmlDoc.evaluate(selector, htmlDoc, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
+            for (let node = it.iterateNext(); node; node = it.iterateNext()) {
+              // -1 for the body element
+              const nodeIndex = rootDivChildElements.indexOf(node) - 1;
+              if (nodeIndex >= 0) {
+                const originalNode = csrChildElements[nodeIndex];
+                if (originalNode.nodeType === Node.ELEMENT_NODE)
+                  result.push(originalNode as Element);
+              }
+            }
+            return result;
+          }
+        
     if (selector.startsWith('/') && root.nodeType !== Node.DOCUMENT_NODE)
       selector = '.' + selector;
     const result: Element[] = [];
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/browserContext.ts patchright/packages/playwright-core/src/server/browserContext.ts
---
+++
@@ -164,7 +164,7 @@
       await this.exposeConsoleApi();
 
     if (this._options.serviceWorkers === 'block')
-      await this.addInitScript(undefined, `\nif (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };\n`);
+      await this.addInitScript(undefined, `navigator.serviceWorker.register = async () => { };`);
 
     if (this._options.permissions)
       await this.grantPermissions(this._options.permissions);
@@ -354,27 +354,19 @@
       if (page.getBinding(name))
         throw new Error(`Function "${name}" has been already registered in one of the pages`);
     }
-    await progress.race(this.exposePlaywrightBindingIfNeeded());
     const binding = new PageBinding(name, playwrightBinding, needsHandle);
     binding.forClient = forClient;
     this._pageBindings.set(name, binding);
-    try {
-      await progress.race(this.doAddInitScript(binding.initScript));
-      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));
-      return binding;
-    } catch (error) {
-      this._pageBindings.delete(name);
-      throw error;
-    }
+    await this.doExposeBinding(binding);
   }
 
   async removeExposedBindings(bindings: PageBinding[]) {
-    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);
-    for (const binding of bindings)
-      this._pageBindings.delete(binding.name);
-    await this.doRemoveInitScripts(bindings.map(binding => binding.initScript));
-    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\n`).join('');
-    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');
+
+          for (const key of this._pageBindings.keys()) {
+            if (!key.startsWith('__pw')) this._pageBindings.delete(key);
+          }
+          await this.doRemoveExposedBindings();
+        
   }
 
   async grantPermissions(permissions: string[], origin?: string) {
@@ -491,9 +483,10 @@
   }
 
   async removeInitScripts(initScripts: InitScript[]) {
-    const set = new Set(initScripts);
-    this.initScripts = this.initScripts.filter(script => !set.has(script));
-    await this.doRemoveInitScripts(initScripts);
+
+          this.initScripts.splice(0, this.initScripts.length);
+          await this.doRemoveInitScripts();
+          
   }
 
   async addRequestInterceptor(progress: Progress, handler: network.RouteHandler): Promise<void> {
@@ -843,4 +836,5 @@
   strictSelectors: false,
   serviceWorkers: 'allow',
   locale: 'en-US',
+  focusControl: false
 };
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/chromium/chromiumSwitches.ts patchright/packages/playwright-core/src/server/chromium/chromiumSwitches.ts
---
+++
@@ -51,26 +51,16 @@
   '--disable-field-trial-config', // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
   '--disable-background-networking',
   '--disable-background-timer-throttling',
-  '--disable-backgrounding-occluded-windows',
-  '--disable-back-forward-cache', // Avoids surprises like main request not being intercepted during page.goBack().
-  '--disable-breakpad',
-  '--disable-client-side-phishing-detection',
-  '--disable-component-extensions-with-background-pages',
-  '--disable-component-update', // Avoids unneeded network activity after startup.
+  '--disable-backgrounding-occluded-windows', // Avoids surprises like main request not being intercepted during page.goBack().
+  '--disable-breakpad', // Avoids unneeded network activity after startup.
   '--no-default-browser-check',
-  '--disable-default-apps',
   '--disable-dev-shm-usage',
-  '--disable-extensions',
   '--disable-features=' + disabledFeatures(assistantMode).join(','),
   process.env.PLAYWRIGHT_LEGACY_SCREENSHOT ? '' : '--enable-features=CDPScreenshotNewSurface',
-  '--allow-pre-commit-input',
   '--disable-hang-monitor',
-  '--disable-ipc-flooding-protection',
-  '--disable-popup-blocking',
   '--disable-prompt-on-repost',
   '--disable-renderer-backgrounding',
   '--force-color-profile=srgb',
-  '--metrics-recording-only',
   '--no-first-run',
   '--password-store=basic',
   '--use-mock-keychain',
@@ -79,11 +69,8 @@
   '--export-tagged-pdf',
   // https://chromium-review.googlesource.com/c/chromium/src/+/4853540
   '--disable-search-engine-choice-screen',
-  // https://issues.chromium.org/41491762
-  '--unsafely-disable-devtools-self-xss-warnings',
   // Edge can potentially restart on Windows (msRelaunchNoCompatLayer) which looses its file descriptors (stdout/stderr) and CDP (3/4). Disable until fixed upstream.
   '--edge-skip-compat-layer-relaunch',
-  assistantMode ? '' : '--enable-automation',
   // This disables Chrome for Testing infobar that is visible in the persistent context.
   // The switch is ignored everywhere else, including Chromium/Chrome/Edge.
   '--disable-infobars',
@@ -91,4 +78,5 @@
   '--disable-search-engine-choice-screen',
   // Prevents the "three dots" menu crash in IdentityManager::HasPrimaryAccount for ephemeral contexts.
   android ? '' : '--disable-sync',
+  '--disable-blink-features=AutomationControlled'
 ].filter(Boolean);
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/chromium/crBrowser.ts patchright/packages/playwright-core/src/server/chromium/crBrowser.ts
---
+++
@@ -519,8 +519,9 @@
   }
 
   async doRemoveInitScripts(initScripts: InitScript[]) {
-    for (const page of this.pages())
-      await (page.delegate as CRPage).removeInitScripts(initScripts);
+
+          for (const page of this.pages()) await (page.delegate as CRPage).removeInitScripts();
+        
   }
 
   async doUpdateRequestInterception(): Promise<void> {
@@ -613,4 +614,16 @@
     const rootSession = await this._browser._clientRootSession();
     return rootSession.attachToTarget(targetId);
   }
+
+  async doExposeBinding(binding: PageBinding) {
+
+          for (const page of this.pages()) await (page.delegate as CRPage).exposeBinding(binding);
+        
+  }
+
+  async doRemoveExposedBindings() {
+
+          for (const page of this.pages()) await (page.delegate as CRPage).removeExposedBindings();
+        
+  }
 }
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/chromium/crDevTools.ts patchright/packages/playwright-core/src/server/chromium/crDevTools.ts
---
+++
@@ -64,7 +64,6 @@
       }).catch(e => null);
     });
     Promise.all([
-      session.send('Runtime.enable'),
       session.send('Runtime.addBinding', { name: kBindingName }),
       session.send('Page.enable'),
       session.send('Page.addScriptToEvaluateOnNewDocument', { source: `
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/chromium/crNetworkManager.ts patchright/packages/playwright-core/src/server/chromium/crNetworkManager.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -156,7 +158,7 @@
     const enabled = this._protocolRequestInterceptionEnabled;
     if (initial && !enabled)
       return;
-    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: enabled });
+    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: false });
     let fetchPromise = Promise.resolve<any>(undefined);
     if (!info.workerFrame) {
       if (enabled)
@@ -238,6 +240,7 @@
   }
 
   _onRequestPaused(sessionInfo: SessionInfo, event: Protocol.Fetch.requestPausedPayload) {
+    if (this._alreadyTrackedNetworkIds.has(event.networkId)) return;
     if (!event.networkId) {
       // Fetch without networkId means that request was not recognized by inspector, and
       // it will never receive Network.requestWillBeSent. Continue the request to not affect it.
@@ -276,6 +279,7 @@
   }
 
   _onRequest(requestWillBeSentSessionInfo: SessionInfo, requestWillBeSentEvent: Protocol.Network.requestWillBeSentPayload, requestPausedSessionInfo: SessionInfo | undefined, requestPausedEvent: Protocol.Fetch.requestPausedPayload | undefined) {
+    if (this._alreadyTrackedNetworkIds.has(requestWillBeSentEvent.initiator.requestId)) return;
     if (requestWillBeSentEvent.request.url.startsWith('data:'))
       return;
     let redirectedFrom: InterceptableRequest | null = null;
@@ -346,7 +350,7 @@
         }
         requestPausedSessionInfo!.session._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId, headers: headersOverride });
       } else {
-        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId);
+        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId, this._page, requestPausedEvent.networkId, this);
       }
     }
     const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';
@@ -557,6 +561,8 @@
     if (request.session !== sessionInfo.session && !sessionInfo.isMain && (request._documentId === request._requestId || sessionInfo.workerFrame))
       request.session = sessionInfo.session;
   }
+
+  _alreadyTrackedNetworkIds: Set<string> = new Set();
 }
 
 class InterceptableRequest {
@@ -615,38 +621,213 @@
   _alreadyContinuedParams: Protocol.Fetch.continueRequestParameters | undefined;
   _fulfilled: boolean = false;
 
-  constructor(session: CRSession, interceptionId: string) {
+  constructor(session: CRSession, interceptionId: string, page, networkId, sessionManager) {
+    this._sessionManager = void 0;
+    this._networkId = void 0;
+    this._page = void 0;
     this._session = session;
     this._interceptionId = interceptionId;
+    this._page = page;
+    this._networkId = networkId;
+    this._sessionManager = sessionManager;
+    eventsHelper.addEventListener(this._session, 'Fetch.requestPaused', async e => await this._networkRequestIntercepted(e));
   }
 
   async continue(overrides: types.NormalizedContinueOverrides): Promise<void> {
-    this._alreadyContinuedParams = {
-      requestId: this._interceptionId!,
-      url: overrides.url,
-      headers: overrides.headers,
-      method: overrides.method,
-      postData: overrides.postData ? overrides.postData.toString('base64') : undefined
-    };
-    await catchDisallowedErrors(async () => {
-      await this._session.send('Fetch.continueRequest', this._alreadyContinuedParams);
-    });
+
+          this._alreadyContinuedParams = {
+            requestId: this._interceptionId,
+            url: overrides.url,
+            headers: overrides.headers,
+            method: overrides.method,
+            postData: overrides.postData ? overrides.postData.toString('base64') : undefined,
+          };
+          if (overrides.url && (overrides.url === 'http://patchright-init-script-inject.internal/' || overrides.url === 'https://patchright-init-script-inject.internal/')) {
+            await catchDisallowedErrors(async () => {
+              this._sessionManager._alreadyTrackedNetworkIds.add(this._networkId);
+              this._session._sendMayFail('Fetch.continueRequest', { requestId: this._interceptionId, interceptResponse: true });
+            });
+          } else {
+            await catchDisallowedErrors(async () => {
+              await this._session._sendMayFail('Fetch.continueRequest', this._alreadyContinuedParams);
+            });
+          }
+        
   }
 
   async fulfill(response: types.NormalizedFulfillResponse) {
-    this._fulfilled = true;
-    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
 
-    const responseHeaders = splitSetCookieHeader(response.headers);
-    await catchDisallowedErrors(async () => {
-      await this._session.send('Fetch.fulfillRequest', {
-        requestId: this._interceptionId!,
-        responseCode: response.status,
-        responsePhrase: network.statusText(response.status),
-        responseHeaders,
-        body,
-      });
-    });
+          const isTextHtml = response.headers.some((header) => header.name.toLowerCase() === "content-type" && header.value.includes("text/html"));
+          var allInjections = [...this._page.delegate._mainFrameSession._evaluateOnNewDocumentScripts];
+          if (isTextHtml && allInjections.length) {
+            let useNonce = false;
+            let scriptNonce = null;
+            // Decode body if needed
+            if (response.isBase64) {
+              response.isBase64 = false;
+              response.body = Buffer.from(response.body, "base64").toString("utf-8");
+            }
+            // === CSP Detection and Fixing ===
+            const cspHeaderNames = ["content-security-policy", "content-security-policy-report-only"];
+            // Fix CSP in headers
+            for (let i = 0; i < response.headers.length; i++) {
+              const headerName = response.headers[i].name.toLowerCase();
+              if (cspHeaderNames.includes(headerName)) {
+                const originalCsp = response.headers[i].value || "";
+                // Extract nonce if present
+                if (!useNonce) {
+                  const nonceMatch = originalCsp.match(/script-src[^;]*'nonce-([^'"\s;]+)'/i);
+                  if (nonceMatch && nonceMatch[1]) {
+                    scriptNonce = nonceMatch[1];
+                    useNonce = true;
+                  }
+                }
+                
+                const fixedCsp = this._fixCSP(originalCsp, scriptNonce);
+                response.headers[i].value = fixedCsp;
+              }
+            }
+            
+            // Fix CSP in meta tags
+            if (typeof response.body === "string" && response.body.length) {
+              response.body = response.body.replace(
+                /<meta[^>]*http-equiv=(?:"|')?Content-Security-Policy(?:"|')?[^>]*>/gi,
+                (match) => {
+                  const contentMatch = match.match(/content=(?:"|')([^"']*)(?:"|')/i);
+                  if (contentMatch && contentMatch[1]) {
+                    let originalCsp = contentMatch[1];
+                    
+                    // Decode HTML entities
+                    originalCsp = originalCsp.replace(/&amp;/g, '&')  // Must be first!
+                        .replace(/&lt;/g, '<')
+                        .replace(/&gt;/g, '>')
+                        .replace(/&quot;/g, '"')
+                        .replace(/&#x27;/g, "'")
+                        .replace(/&#x22;/g, '"')
+                        .replace(/&nbsp;/g, ' ')
+                        .replace(/&#(d+);/g, (match, dec) => String.fromCharCode(dec))
+                        .replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));
+                    
+                    // Extract nonce if not already found
+                    if (!useNonce) {
+                      const nonceMatch = originalCsp.match(/script-src[^;]*'nonce-([^'"\s;]+)'/i);
+                      if (nonceMatch && nonceMatch[1]) {
+                        scriptNonce = nonceMatch[1];
+                        useNonce = true;
+                      }
+                    }
+                    
+                    const fixedCsp = this._fixCSP(originalCsp, scriptNonce);
+                    // Re-encode for HTML
+                    const encodedCsp = fixedCsp.replace(/'/g, '&#x27;').replace(/"/g, '&#x22;');
+                    return match.replace(contentMatch[1], encodedCsp);
+                  }
+                  return match;
+                }
+              );
+            }
+            
+            // Build injection HTML - only use nonce if one was found in existing CSP
+            let injectionHTML = "";
+            allInjections.forEach((script) => {
+              let scriptId = crypto.randomBytes(22).toString("hex");
+              let scriptSource = script.source || script;
+              const nonceAttr = useNonce ? `nonce="${scriptNonce}"` : '';
+              injectionHTML += `<script class="${this._page.delegate.initScriptTag}" ${nonceAttr} id="${scriptId}" type="text/javascript">document.getElementById("${scriptId}")?.remove();${scriptSource}</script>`;
+            });
+
+            // Inject at END of <head>
+            const lower = response.body.toLowerCase();
+            const headStartIndex = lower.indexOf("<head");
+            if (headStartIndex !== -1) {
+              const headEndTagIndex = lower.indexOf("</head>", headStartIndex);
+              if (headEndTagIndex !== -1) {
+                // Find the head opening tag end
+                const headOpenEnd = response.body.indexOf(">", headStartIndex) + 1;
+                const headContent = response.body.slice(headOpenEnd, headEndTagIndex);
+                const headContentLower = headContent.toLowerCase();
+                
+                // Look for the first <script> tag in the head content
+                // but ignore comments
+                let firstScriptIndex = -1;
+                let searchPos = 0;
+                const endSearchPos = headContentLower.length;
+
+                while (searchPos < endSearchPos) {
+                    const commentStart = headContentLower.indexOf("<!--", searchPos);
+                    const scriptStart = headContentLower.indexOf("<script", searchPos);
+                    // No more script tags, inject at the end of head content
+                    if (scriptStart === -1 || scriptStart >= endSearchPos) {
+                        break;
+                    }
+
+                    if (commentStart !== -1 && commentStart < scriptStart) {
+                        const commentEnd = headContentLower.indexOf("-->", commentStart);
+                        if (commentEnd !== -1) {
+                            // continue search after the comment
+                            searchPos = commentEnd + 3;
+                            continue;
+                        } else {
+                            break;
+                        }
+                    }
+
+                    // Found a script tag
+                    firstScriptIndex = scriptStart;
+                    break;
+                }
+                
+                if (firstScriptIndex !== -1) {
+                  // Inject before the first script tag
+                  const insertPosition = headOpenEnd + firstScriptIndex;
+                  response.body =
+                    response.body.slice(0, insertPosition) +
+                    injectionHTML +
+                    response.body.slice(insertPosition);
+                } else {
+                  // No script tags found, inject at the end of head content (before </head>)
+                  response.body =
+                    response.body.slice(0, headEndTagIndex) +
+                    injectionHTML +
+                    response.body.slice(headEndTagIndex);
+                }
+              } else {
+                const headStartTagEnd = response.body.indexOf(">", headStartIndex) + 1;
+                response.body =
+                  response.body.slice(0, headStartTagEnd) +
+                  injectionHTML +
+                  response.body.slice(headStartTagEnd);
+              }
+            } else {
+              const doctypeIndex = lower.indexOf("<!doctype");
+              if (doctypeIndex === 0) {
+                const doctypeEnd = response.body.indexOf(">", doctypeIndex) + 1;
+                response.body = response.body.slice(0, doctypeEnd) + injectionHTML + response.body.slice(doctypeEnd);
+              } else {
+                const htmlIndex = lower.indexOf("<html");
+                if (htmlIndex !== -1) {
+                  const htmlTagEnd = response.body.indexOf(">", htmlIndex) + 1;
+                  response.body =
+                    response.body.slice(0, htmlTagEnd) + `<head>${injectionHTML}</head>` + response.body.slice(htmlTagEnd);
+                } else {
+                  response.body = injectionHTML + response.body;
+                }
+              }
+            }
+          }
+          this._fulfilled = true;
+          const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
+          const responseHeaders = splitSetCookieHeader(response.headers);
+          await catchDisallowedErrors(async () => {
+            await this._session.send("Fetch.fulfillRequest", {
+              requestId: response.interceptionId ? response.interceptionId : this._interceptionId,
+              responseCode: response.status,
+              responsePhrase: network.statusText(response.status),
+              responseHeaders,
+              body
+            });
+          });
+        
   }
 
   async abort(errorCode: string = 'failed') {
@@ -659,6 +840,155 @@
       });
     });
   }
+
+  _fixCSP(csp, scriptNonce) {
+
+          if (!csp || typeof csp !== 'string') return csp;
+
+          // Split by semicolons and clean up
+          const directives = csp.split(';')
+            .map(d => d.trim())
+            .filter(d => d && d.length > 0);
+
+          const fixedDirectives = [];
+          let hasScriptSrc = false;
+
+          for (let directive of directives) {
+            // Skip empty directives
+            if (!directive.trim()) continue;
+
+            // Improved directive parsing to handle more edge cases
+            const directiveMatch = directive.match(/^([a-zA-Z-]+)\s+(.*)$/);
+            if (!directiveMatch) {
+              fixedDirectives.push(directive);
+              continue;
+            }
+
+            const directiveName = directiveMatch[1].toLowerCase();
+            const directiveValues = directiveMatch[2].split(/\s+/).filter(v => v.length > 0);
+
+            switch (directiveName) {
+              case 'script-src':
+                hasScriptSrc = true;
+                let values = [...directiveValues];
+
+                // Add nonce if we have one and it's not already present
+                if (scriptNonce && !values.some(v => v.includes(`nonce-${scriptNonce}`))) {
+                  values.push(`'nonce-${scriptNonce}'`);
+                }
+
+                // Add 'unsafe-eval' if not present
+                if (!values.includes("'unsafe-eval'")) {
+                  values.push("'unsafe-eval'");
+                }
+
+                // Add unsafe-inline if not present and no nonce is being used
+                if (!values.includes("'unsafe-inline'") && !scriptNonce) {
+                  values.push("'unsafe-inline'");
+                }
+
+                // Add wildcard for external scripts if not already present
+                if (!values.includes("*") && !values.includes("'self'") && !values.some(v => v.includes("https:"))) {
+                  values.push("*");
+                }
+
+                fixedDirectives.push(`script-src ${values.join(' ')}`);
+                break;
+
+              case 'style-src':
+                let styleValues = [...directiveValues];
+                // Add 'unsafe-inline' for styles if not present
+                if (!styleValues.includes("'unsafe-inline'")) {
+                  styleValues.push("'unsafe-inline'");
+                }
+                fixedDirectives.push(`style-src ${styleValues.join(' ')}`);
+                break;
+
+              case 'img-src':
+                let imgValues = [...directiveValues];
+                // Allow data: URLs for images if not already allowed
+                if (!imgValues.includes("data:") && !imgValues.includes("*")) {
+                  imgValues.push("data:");
+                }
+                fixedDirectives.push(`img-src ${imgValues.join(' ')}`);
+                break;
+
+              case 'font-src':
+                let fontValues = [...directiveValues];
+                // Allow data: URLs for fonts if not already allowed
+                if (!fontValues.includes("data:") && !fontValues.includes("*")) {
+                  fontValues.push("data:");
+                }
+                fixedDirectives.push(`font-src ${fontValues.join(' ')}`);
+                break;
+
+              case 'connect-src':
+                let connectValues = [...directiveValues];
+                // Allow WebSocket connections if not already allowed
+                const hasWs = connectValues.some(v => v.includes("ws:") || v.includes("wss:") || v === "*");
+                if (!hasWs) {
+                  connectValues.push("ws:", "wss:");
+                }
+                fixedDirectives.push(`connect-src ${connectValues.join(' ')}`);
+                break;
+
+              case 'frame-ancestors':
+                let frameAncestorValues = [...directiveValues];
+                // If completely blocked with 'none', allow 'self' at least
+                if (frameAncestorValues.includes("'none'")) {
+                  frameAncestorValues = ["'self'"];
+                }
+                fixedDirectives.push(`frame-ancestors ${frameAncestorValues.join(' ')}`);
+                break;
+
+              default:
+                // Keep other directives as-is
+                fixedDirectives.push(directive);
+                break;
+            }
+          }
+
+          // Add script-src if it doesn't exist (for our injected scripts)
+          if (!hasScriptSrc) {
+            if (scriptNonce) {
+              fixedDirectives.push(`script-src 'self' 'unsafe-eval' 'nonce-${scriptNonce}' *`);
+            } else {
+              fixedDirectives.push(`script-src 'self' 'unsafe-eval' 'unsafe-inline' *`);
+            }
+          }
+
+          return fixedDirectives.join('; ');
+        
+  }
+
+  async _networkRequestIntercepted(event) {
+
+          if (event.resourceType !== 'Document') {
+            /*await catchDisallowedErrors(async () => {
+              await this._session.send('Fetch.continueRequest', { requestId: event.requestId });
+            });*/
+            return;
+          }
+          if (this._networkId != event.networkId || !this._sessionManager._alreadyTrackedNetworkIds.has(event.networkId)) return;
+          try {
+            if (event.responseStatusCode >= 301 && event.responseStatusCode <= 308  || (event.redirectedRequestId && !event.responseStatusCode)) {
+              await this._session.send('Fetch.continueRequest', { requestId: event.requestId, interceptResponse: true });
+            } else {
+              const responseBody = await this._session.send('Fetch.getResponseBody', { requestId: event.requestId });
+              await this.fulfill({
+                headers: event.responseHeaders,
+                isBase64: true,
+                body: responseBody.body,
+                status: event.responseStatusCode,
+                interceptionId: event.requestId,
+                resourceType: event.resourceType,
+              })
+            }
+          } catch (error) {
+            await this._session._sendMayFail('Fetch.continueRequest', { requestId: event.requestId });
+          }
+        
+  }
 }
 
 // In certain cases, protocol will return error if the request was already canceled
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/chromium/crPage.ts patchright/packages/playwright-core/src/server/chromium/crPage.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -94,7 +96,8 @@
     this.updateOffline();
     this.updateExtraHTTPHeaders();
     this.updateHttpCredentials();
-    this.updateRequestInterception();
+    this._networkManager.setRequestInterception(true);
+        this.initScriptTag = crypto.randomBytes(20).toString('hex');
     this._mainFrameSession = new FrameSession(this, client, targetId, null);
     this._sessions.set(targetId, this._mainFrameSession);
     if (opener && !browserContext._options.noDefaultViewport) {
@@ -223,6 +226,7 @@
   }
 
   async addInitScript(initScript: InitScript, world: types.World = 'main'): Promise<void> {
+    this._page.initScripts.push(initScript);
     await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(initScript, world));
   }
 
@@ -356,6 +360,19 @@
   shouldToggleStyleSheetToSyncAnimations(): boolean {
     return false;
   }
+
+  async exposeBinding(binding) {
+
+          await this._forAllFrameSessions(frame => frame._initBinding(binding));
+          await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source).catch(e => {})));
+        
+  }
+
+  async removeExposedBindings() {
+
+          await this._forAllFrameSessions(frame => frame._removeExposedBindings());
+        
+  }
 }
 
 class FrameSession {
@@ -465,17 +482,6 @@
         this._bufferedAttachedToTargetEvents = undefined;
         for (const event of attachedToTargetEvents)
           this._onAttachedToTarget(event);
-
-        const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)!];
-        for (const frame of localFrames) {
-          // Note: frames might be removed before we send these.
-          this._client._sendMayFail('Page.createIsolatedWorld', {
-            frameId: frame._id,
-            grantUniveralAccess: true,
-            worldName: this._crPage.utilityWorldName,
-          });
-        }
-
         const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';
         if (isInitialEmptyPage) {
           // Ignore lifecycle events, worlds and bindings for the initial empty page. It is never the final page
@@ -485,13 +491,22 @@
             this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
           });
         } else {
+
+                  const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)!];
+                    for (const frame of localFrames) {
+                      this._page.frameManager.frame(frame._id)._context("utility");
+                      for (const binding of this._crPage._browserContext._pageBindings.values())
+                        frame.evaluateExpression(binding.source).catch(e => {});
+                      for (const source of this._crPage._browserContext.initScripts)
+                        frame.evaluateExpression(source).catch(e => {});
+                    }
+                  
           this._firstNonInitialNavigationCommittedFulfill();
           this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
         }
       }),
       this._client.send('Log.enable', {}),
       lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-      this._client.send('Runtime.enable', {}),
       this._client.send('Page.addScriptToEvaluateOnNewDocument', {
         source: '',
         worldName: this._crPage.utilityWorldName,
@@ -502,8 +517,10 @@
     if (!this._page.isStorageStatePage) {
       if (this._crPage._browserContext.needsPlaywrightBinding())
         promises.push(this.exposePlaywrightBinding());
-      if (this._isMainFrame())
-        promises.push(this._client.send('Emulation.setFocusEmulationEnabled', { enabled: true }));
+      
+              if (this._isMainFrame() && !this._crPage._browserContext._options.focusControl)
+                  promises.push(this._client.send("Emulation.setFocusEmulationEnabled", { enabled: true }));
+              
       const options = this._crPage._browserContext._options;
       if (options.bypassCSP)
         promises.push(this._client.send('Page.setBypassCSP', { enabled: true }));
@@ -526,14 +543,24 @@
       promises.push(this._updateGeolocation(true));
       promises.push(this._updateEmulateMedia());
       promises.push(this._updateFileChooserInterception(true));
-      for (const initScript of this._crPage._page.allInitScripts())
-        promises.push(this._evaluateOnNewDocument(initScript, 'main', true /* runImmediately */));
+      
+                    for (const binding of this._crPage._page.allBindings()) promises.push(this._initBinding(binding));
+                    for (const initScript of this._crPage._browserContext.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+                    for (const initScript of this._crPage._page.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+                  
       if (videoOptions)
         promises.push(this._crPage._page.screencast.startVideoRecording(videoOptions));
     }
-    promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+    
+            if (!(this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size))
+              promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+          
     promises.push(this._firstNonInitialNavigationCommittedPromise);
     await Promise.all(promises);
+
+            if (this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size)
+              await this._client.send('Runtime.runIfWaitingForDebugger');
+          
   }
 
   dispose() {
@@ -557,13 +584,25 @@
     return { newDocumentId: response.loaderId };
   }
 
-  _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
+  async _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
     if (this._eventBelongsToStaleFrame(event.frameId))
       return;
     if (event.name === 'load')
       this._page.frameManager.frameLifecycleEvent(event.frameId, 'load');
     else if (event.name === 'DOMContentLoaded')
       this._page.frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
+    await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          var document = await this._client._sendMayFail("DOM.getDocument");
+          if (!document) return
+          var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+            nodeId: document.root.nodeId,
+            selector: "[class=" + this._crPage.initScriptTag + "]"
+          });
+          if (!query) return
+          for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+          await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          // ensuring execution context
+          try { await this._page.frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _handleFrameTree(frameTree: Protocol.Page.FrameTree) {
@@ -610,12 +649,24 @@
     this._page.frameManager.frameAttached(frameId, parentFrameId);
   }
 
-  _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
+  async _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
     if (this._eventBelongsToStaleFrame(framePayload.id))
       return;
     this._page.frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);
     if (!initial)
       this._firstNonInitialNavigationCommittedFulfill();
+    await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          var document = await this._client._sendMayFail("DOM.getDocument");
+          if (!document) return
+          var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+            nodeId: document.root.nodeId,
+            selector: "[class=" + this._crPage.initScriptTag + "]"
+          });
+          if (!query) return
+          for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+          await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          // ensuring execution context
+          try { await this._page.frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _onFrameRequestedNavigation(payload: Protocol.Page.frameRequestedNavigationPayload) {
@@ -652,19 +703,31 @@
   }
 
   _onExecutionContextCreated(contextPayload: Protocol.Runtime.ExecutionContextDescription) {
+
+          for (const name of this._exposedBindingNames)
+            this._client._sendMayFail('Runtime.addBinding', { name: name, executionContextId: contextPayload.id });
+        
     const frame = contextPayload.auxData ? this._page.frameManager.frame(contextPayload.auxData.frameId) : null;
+
+          if (contextPayload.auxData.type == "worker") throw new Error("ExecutionContext is worker");
+        
     if (!frame || this._eventBelongsToStaleFrame(frame._id))
       return;
     const delegate = new CRExecutionContext(this._client, contextPayload);
-    let worldName: types.World|null = null;
-    if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
-      worldName = 'main';
-    else if (contextPayload.name === this._crPage.utilityWorldName)
-      worldName = 'utility';
+    let worldName = contextPayload.name;
     const context = new dom.FrameExecutionContext(delegate, frame, worldName);
     if (worldName)
       frame._contextCreated(worldName, context);
     this._contextIdToContext.set(contextPayload.id, context);
+
+          for (const source of this._exposedBindingScripts) {
+            this._client._sendMayFail("Runtime.evaluate", {
+              expression: source,
+              contextId: contextPayload.id,
+              awaitPromise: true,
+            })
+          }
+        
   }
 
   _onExecutionContextDestroyed(executionContextId: number) {
@@ -680,7 +743,7 @@
       this._onExecutionContextDestroyed(contextId);
   }
 
-  _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
+  async _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
     if (this._bufferedAttachedToTargetEvents) {
       this._bufferedAttachedToTargetEvents.push(event);
       return;
@@ -722,12 +785,22 @@
     session.once('Runtime.executionContextCreated', async event => {
       worker.createExecutionContext(new CRExecutionContext(session, event.context));
     });
+
+          var globalThis = await session._sendMayFail('Runtime.evaluate', {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          });
+          if (globalThis && globalThis.result) {
+            var globalThisObjId = globalThis.result.objectId;
+            var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+            worker.createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+          }
+        
     if (this._crPage._browserContext._browser.majorVersion() >= 143)
       session.on('Inspector.workerScriptLoaded', () => worker.workerScriptLoaded());
     else
       worker.workerScriptLoaded();
     // This might fail if the target is closed before we initialize.
-    session._sendMayFail('Runtime.enable');
     // TODO: attribute workers to the right frame.
     this._crPage._networkManager.addSession(session, this._page.frameManager.frame(this._targetId) ?? undefined).catch(() => {});
     session._sendMayFail('Runtime.runIfWaitingForDebugger');
@@ -1002,20 +1075,11 @@
   }
 
   async _evaluateOnNewDocument(initScript: InitScript, world: types.World, runImmediately?: boolean): Promise<void> {
-    const worldName = world === 'utility' ? this._crPage.utilityWorldName : undefined;
-    const { identifier } = await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: initScript.source, worldName, runImmediately });
-    this._initScriptIds.set(initScript, identifier);
+    this._evaluateOnNewDocumentScripts.push(initScript)
   }
 
   async _removeEvaluatesOnNewDocument(initScripts: InitScript[]): Promise<void> {
-    const ids: string[] = [];
-    for (const script of initScripts) {
-      const id = this._initScriptIds.get(script);
-      if (id)
-        ids.push(id);
-      this._initScriptIds.delete(script);
-    }
-    await Promise.all(ids.map(identifier => this._client.send('Page.removeScriptToEvaluateOnNewDocument', { identifier }).catch(() => {}))); // target can be closed
+    this._evaluateOnNewDocumentScripts = [];
   }
 
   async exposePlaywrightBinding() {
@@ -1126,6 +1190,48 @@
       throw new Error(dom.kUnableToAdoptErrorMessage);
     return createHandle(to, result.object).asElement()!;
   }
+
+  _exposedBindingNames: string[] = [];
+  _evaluateOnNewDocumentScripts: string[] = [];
+  _parsedExecutionContextIds: number[] = [];
+  _exposedBindingScripts: string[] = [];
+
+  async _initBinding(binding = PageBinding) {
+
+          var result = await this._client._sendMayFail('Page.createIsolatedWorld', {
+            frameId: this._targetId, grantUniveralAccess: true, worldName: "utility"
+          });
+          if (!result) return
+          var isolatedContextId = result.executionContextId
+
+          var globalThis = await this._client._sendMayFail('Runtime.evaluate', {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          });
+          if (!globalThis) return
+          var globalThisObjId = globalThis["result"]['objectId']
+          var mainContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+          await Promise.all([
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name }),
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: mainContextId }),
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: isolatedContextId }),
+            // this._client._sendMayFail("Runtime.evaluate", { expression: binding.source, contextId: mainContextId, awaitPromise: true })
+          ]);
+          this._exposedBindingNames.push(binding.name);
+          this._exposedBindingScripts.push(binding.source);
+          //this._client._sendMayFail('Runtime.runIfWaitingForDebugger')
+  }
+
+  async _removeExposedBindings() {
+    const toRetain: string[] = [];
+          const toRemove: string[] = [];
+          for (const name of this._exposedBindingNames)
+            (name.startsWith('__pw_') ? toRetain : toRemove).push(name);
+          this._exposedBindingNames = toRetain;
+          await Promise.all(toRemove.map(name => this._client.send('Runtime.removeBinding', { name })));
+        
+  }
 }
 
 async function emulateLocale(session: CRSession, locale: string) {
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/chromium/crServiceWorker.ts patchright/packages/playwright-core/src/server/chromium/crServiceWorker.ts
---
+++
@@ -58,13 +58,23 @@
       const message = new ConsoleMessage(null, this, event.type, undefined, args, toConsoleMessageLocation(event.stackTrace));
       this.browserContext.emit(BrowserContext.Events.Console, message);
     });
-
-    session.send('Runtime.enable', {}).catch(e => { });
     session.send('Runtime.runIfWaitingForDebugger').catch(e => { });
     session.on('Inspector.targetReloadedAfterCrash', () => {
       // Resume service worker after restart.
       session._sendMayFail('Runtime.runIfWaitingForDebugger', {});
     });
+
+          session._sendMayFail("Runtime.evaluate", {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          }).then(globalThis => {
+            if (globalThis && globalThis.result) {
+              var globalThisObjId = globalThis.result.objectId;
+              var executionContextId = parseInt(globalThisObjId.split(".")[1], 10);
+              this.createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+            }
+          });
+        
   }
 
   override didClose() {
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/clock.ts patchright/packages/playwright-core/src/server/clock.ts
---
+++
@@ -106,6 +106,16 @@
   }
 
   private async _evaluateInFrames(script: string) {
+
+          // Dont ask me why this works
+          await Promise.all(this._browserContext.pages().map(async page => {
+            await Promise.all(page.frames().map(async frame => {
+              try {
+                await frame.evaluateExpression("");
+              } catch (e) {}
+            }));
+          }));
+        
     await this._browserContext.safeNonStallingEvaluateInAllFrames(script, 'main', { throwOnJSErrors: true });
   }
 }
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/dispatchers/frameDispatcher.ts patchright/packages/playwright-core/src/server/dispatchers/frameDispatcher.ts
---
+++
@@ -84,11 +84,15 @@
   }
 
   async evaluateExpression(params: channels.FrameEvaluateExpressionParams, progress: Progress): Promise<channels.FrameEvaluateExpressionResult> {
-    return { value: serializeResult(await progress.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
+
+          return { value: serializeResult(await progress.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction, world: params.isolatedContext ? 'utility': 'main' }, parseArgument(params.arg)))) };
+        
   }
 
   async evaluateExpressionHandle(params: channels.FrameEvaluateExpressionHandleParams, progress: Progress): Promise<channels.FrameEvaluateExpressionHandleResult> {
-    return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
+
+          return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction, world: params.isolatedContext ? 'utility': 'main' }, parseArgument(params.arg)))) };
+        
   }
 
   async waitForSelector(params: channels.FrameWaitForSelectorParams, progress: Progress): Promise<channels.FrameWaitForSelectorResult> {
@@ -104,7 +108,9 @@
   }
 
   async evalOnSelectorAll(params: channels.FrameEvalOnSelectorAllParams, progress: Progress): Promise<channels.FrameEvalOnSelectorAllResult> {
-    return { value: serializeResult(await progress.race(this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg)))) };
+
+          return { value: serializeResult(await this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg), null, params.isolatedContext)) };
+        
   }
 
   async querySelector(params: channels.FrameQuerySelectorParams, progress: Progress): Promise<channels.FrameQuerySelectorResult> {
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/frameSelectors.ts patchright/packages/playwright-core/src/server/frameSelectors.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import { ElementHandle } from './dom';
 /**
  * Copyright (c) Microsoft Corporation.
  *
@@ -65,8 +67,8 @@
     return adoptIfNeeded(elementHandle, await resolved.frame._mainContext());
   }
 
-  async queryArrayInMainWorld(selector: string, scope?: ElementHandle): Promise<JSHandle<Element[]>> {
-    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: true }, scope);
+  async queryArrayInMainWorld(selector: string, scope?: ElementHandle, isolatedContext?: boolean): Promise<JSHandle<Element[]>> {
+    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: !isolatedContext }, scope);
     // Be careful, |this.frame| can be different from |resolved.frame|.
     if (!resolved)
       throw new Error(`Failed to find frame for selector "${selector}"`);
@@ -156,9 +158,31 @@
           throw injected.createStacklessError(`Selector "${selectorString}" resolved to ${injected.previewNode(element)}, <iframe> was expected`);
         return element;
       }, { info, scope: i === 0 ? scope : undefined, selectorString: stringifySelector(info.parsed) });
-      const element = handle.asElement() as ElementHandle<Element> | null;
-      if (!element)
-        return null;
+      let element = handle.asElement() as ElementHandle<Element> | null;
+      
+            if (!element) {
+              try {
+                var client = frame._page.delegate._sessionForFrame(frame)._client;
+              } catch (e) {
+                var client = frame._page.delegate._mainFrameSession._client;
+              }
+              var mainContext = await frame._context("main");
+              const documentNode = await client.send("Runtime.evaluate", {
+                expression: "document",
+                serializationOptions: {
+                  serialization: "idOnly"
+                },
+                contextId: mainContext.delegate._contextId
+              });
+              const documentScope = new ElementHandle(mainContext, documentNode.result.objectId);
+              var check = await this._customFindFramesByParsed(injectedScript, client, mainContext, documentScope, info.parsed);
+              if (check.length > 0) {
+                element = check[0];
+              } else {
+                return null;
+              }
+            }
+          
       const maybeFrame = await frame._page.delegate.getContentFrame(element);
       element.dispose();
       if (!maybeFrame)
@@ -179,9 +203,166 @@
     if (!resolved)
       return;
     const context = await resolved.frame._context(options?.mainWorld ? 'main' : resolved.info.world);
+    if (!context) throw new Error("Frame was detached");
     const injected = await context.injectedScript();
     return { injected, info: resolved.info, frame: resolved.frame, scope: resolved.scope };
   }
+
+  async _customFindFramesByParsed(injected, client, context, documentScope, parsed) {
+
+          var parsedEdits = { ...parsed };
+          var currentScopingElements = [documentScope];
+          while (parsed.parts.length > 0) {
+            var part = parsed.parts.shift();
+            parsedEdits.parts = [part];
+            var elements = [];
+            var elementsIndexes = [];
+            if (part.name == "nth") {
+              const partNth = Number(part.body);
+              if (partNth > currentScopingElements.length || partNth < -currentScopingElements.length) {
+                return continuePolling;
+              } else {
+                currentScopingElements = [currentScopingElements.at(partNth)];
+                continue;
+              }
+            } else if (part.name == "internal:or") {
+              var orredElements = await this._customFindFramesByParsed(injected, client, context, documentScope, part.body.parsed);
+              elements = currentScopingElements.concat(orredElements);
+            } else if (part.name == "internal:and") {
+              var andedElements = await this._customFindFramesByParsed(injected, client, context, documentScope, part.body.parsed);
+              const backendNodeIds = new Set(andedElements.map((item) => item.backendNodeId));
+              elements = currentScopingElements.filter((item) => backendNodeIds.has(item.backendNodeId));
+            } else {
+              for (const scope of currentScopingElements) {
+                const describedScope = await client.send("DOM.describeNode", {
+                  objectId: scope._objectId,
+                  depth: -1,
+                  pierce: true
+                });
+                var queryingElements = [];
+                let findClosedShadowRoots2 = function(node, results = []) {
+                  if (!node || typeof node !== "object") return results;
+                  if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                    for (const shadowRoot2 of node.shadowRoots) {
+                      if (shadowRoot2.shadowRootType === "closed" && shadowRoot2.backendNodeId) {
+                        results.push(shadowRoot2.backendNodeId);
+                      }
+                      findClosedShadowRoots2(shadowRoot2, results);
+                    }
+                  }
+                  if (node.nodeName !== "IFRAME" && node.children && Array.isArray(node.children)) {
+                    for (const child of node.children) {
+                      findClosedShadowRoots2(child, results);
+                    }
+                  }
+                  return results;
+                };
+                var findClosedShadowRoots = findClosedShadowRoots2;
+                var shadowRootBackendIds = findClosedShadowRoots2(describedScope.node);
+                var shadowRoots = [];
+                for (var shadowRootBackendId of shadowRootBackendIds) {
+                  var resolvedShadowRoot = await client.send("DOM.resolveNode", {
+                    backendNodeId: shadowRootBackendId,
+                    contextId: context.delegate._contextId
+                  });
+                  shadowRoots.push(new ElementHandle(context, resolvedShadowRoot.object.objectId));
+                }
+                for (var shadowRoot of shadowRoots) {
+                  const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed: parsed2 }]) => {
+                    const elements2 = injected.querySelectorAll(parsed2, node);
+                    return elements2;
+                  }, {
+                    parsed: parsedEdits,
+                  });
+                  const shadowElementsAmount = await shadowElements.getProperty("length");
+                  queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+                }
+                const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed: parsed2 }]) => {
+                  const elements2 = injected.querySelectorAll(parsed2, node);
+                  return elements2;
+                }, {
+                  parsed: parsedEdits
+                });
+                const rootElementsAmount = await rootElements.getProperty("length");
+                queryingElements.push([rootElements, rootElementsAmount, injected]);
+                for (var queryedElement of queryingElements) {
+                  var elementsToCheck = queryedElement[0];
+                  var elementsAmount = await queryedElement[1].jsonValue();
+                  var parentNode = queryedElement[2];
+                  for (var i = 0; i < elementsAmount; i++) {
+                    if (parentNode.constructor.name == "ElementHandle") {
+                      var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck: elementsToCheck2 }]) => {
+                        return elementsToCheck2[index];
+                      }, { index: i, elementsToCheck });
+                    } else {
+                      var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck: elementsToCheck2 }) => {
+                        return elementsToCheck2[index];
+                      }, { index: i, elementsToCheck });
+                    }
+                    elementToCheck.parentNode = parentNode;
+                    var resolvedElement = await client.send("DOM.describeNode", {
+                      objectId: elementToCheck._objectId,
+                      depth: -1
+                    });
+                    elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+                    elementToCheck.nodePosition = this._findElementPositionInDomTree(elementToCheck, describedScope.node, context, "");
+                    elements.push(elementToCheck);
+                  }
+                }
+              }
+            }
+            // Sorting elements by their nodePosition, which is a index to the Element in the DOM tree
+            const getParts = (pos) => (pos?.match(/../g) || []).map(Number);
+            elements.sort((a, b) => {
+              const partA = getParts(a.nodePosition);
+              const partB = getParts(b.nodePosition);
+              const maxLength = Math.max(partA.length, partB.length);
+
+              for (let i = 0; i < maxLength; i++) {
+                const aVal = partA[i] ?? -1;
+                const bVal = partB[i] ?? -1;
+                if (aVal !== bVal) return aVal - bVal;
+              }
+              return 0;
+            });
+
+            // Remove duplicates by nodePosition, keeping the first occurrence
+            currentScopingElements = Array.from(
+              new Map(elements.map(e => [e.nodePosition, e])).values()
+            );
+          }
+          return currentScopingElements;
+        
+  }
+
+  _findElementPositionInDomTree(element, queryingElement, documentScope, currentIndex) {
+
+          // Get Element Position in DOM Tree by Indexing it via their children indexes, like a search tree index
+          // Check if backendNodeId matches, if so, return currentIndex
+          if (element.backendNodeId === queryingElement.backendNodeId) {
+            return currentIndex;
+          }
+          // Iterating through children of queryingElement
+          for (const child of queryingElement.children || []) {
+            // Getting index of child in queryingElement's children
+            const childrenNodeIndex = queryingElement.children.indexOf(child);
+            // Further querying the child recursively and appending the children index to the currentIndex
+            const childIndex = this._findElementPositionInDomTree(element, child, documentScope, currentIndex + "." + childrenNodeIndex.toString());
+            if (childIndex !== null) return childIndex;
+          }
+          if (queryingElement.shadowRoots && Array.isArray(queryingElement.shadowRoots)) {
+            // Basically same for CSRs, but we dont have to append its index because patchright treats CSRs like they dont exist
+            for (const shadowRoot of queryingElement.shadowRoots) {
+              if (shadowRoot.shadowRootType === "closed" && shadowRoot.backendNodeId) {
+                const shadowRootHandle = new ElementHandle(documentScope, shadowRoot.backendNodeId);
+                const childIndex = this._findElementPositionInDomTree(element, shadowRootHandle, documentScope, currentIndex);
+                if (childIndex !== null) return childIndex;
+              }
+            }
+          }
+          return null;
+        
+  }
 }
 
 async function adoptIfNeeded<T extends Node>(handle: ElementHandle<T>, context: FrameExecutionContext): Promise<ElementHandle<T>> {
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/frames.ts patchright/packages/playwright-core/src/server/frames.ts
---
+++
@@ -1,3 +1,7 @@
+// patchright - custom imports
+import { CRExecutionContext } from './chromium/crExecutionContext';
+import { FrameExecutionContext } from './dom';
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -239,6 +243,9 @@
       // No pending - just commit a new document.
       frame._currentDocument = { documentId, request: undefined };
     }
+    frame._iframeWorld = undefined;
+    frame._mainWorld = undefined;
+    frame._isolatedWorld = undefined;
 
     frame._onClearLifecycle();
     const navigationEvent: NavigationEvent = { url, name, newDocument: frame._currentDocument, isPublic: true };
@@ -722,12 +729,69 @@
     return this._page.delegate.getFrameElement(this);
   }
 
-  _context(world: types.World): Promise<dom.FrameExecutionContext> {
-    return this._contextData.get(world)!.contextPromise.then(contextOrDestroyedReason => {
-      if (contextOrDestroyedReason instanceof js.ExecutionContext)
-        return contextOrDestroyedReason;
-      throw new Error(contextOrDestroyedReason.destroyedReason);
-    });
+  async _context(world: types.World): Promise<dom.FrameExecutionContext> {
+
+          /* await this._page.delegate._mainFrameSession._client._sendMayFail('DOM.enable');
+          var globalDoc = await this._page.delegate._mainFrameSession._client._sendMayFail('DOM.getFrameOwner', { frameId: this._id });
+          if (globalDoc) {
+            await this._page.delegate._mainFrameSession._client._sendMayFail("DOM.resolveNode", { nodeId: globalDoc.nodeId })
+          } */
+
+          if (this.isDetached()) throw new Error('Frame was detached');
+          try {
+            var client = this._page.delegate._sessionForFrame(this)._client
+          } catch (e) { var client = this._page.delegate._mainFrameSession._client }
+          var iframeExecutionContextId = await this._getFrameMainFrameContextId(client)
+
+          if (world == "main") {
+            // Iframe Only
+            if (this != this._page.mainFrame() && iframeExecutionContextId && this._iframeWorld == undefined) {
+              var executionContextId = iframeExecutionContextId
+              var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+              this._iframeWorld = new FrameExecutionContext(crContext, this, world)
+              this._page.delegate._mainFrameSession._onExecutionContextCreated({
+                id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+              })
+            } else if (this._mainWorld == undefined) {
+              var globalThis = await client._sendMayFail('Runtime.evaluate', {
+                expression: "globalThis",
+                serializationOptions: { serialization: "idOnly" }
+              });
+              if (!globalThis) { return }
+              var globalThisObjId = globalThis["result"]['objectId']
+              var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+              var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+              this._mainWorld = new FrameExecutionContext(crContext, this, world)
+              this._page.delegate._mainFrameSession._onExecutionContextCreated({
+                id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+              })
+            }
+          }
+          if (world != "main" && this._isolatedWorld == undefined) {
+            world = "utility"
+            var result = await client._sendMayFail('Page.createIsolatedWorld', {
+              frameId: this._id, grantUniveralAccess: true, worldName: world
+            });
+            if (!result) {
+              // if (this.isDetached()) throw new Error("Frame was detached");
+              return
+            }
+            var executionContextId = result.executionContextId
+            var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+            this._isolatedWorld = new FrameExecutionContext(crContext, this, world)
+            this._page.delegate._mainFrameSession._onExecutionContextCreated({
+              id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+            })
+          }
+
+          if (world != "main") {
+            return this._isolatedWorld;
+          } else if (this != this._page.mainFrame() && iframeExecutionContextId) {
+            return this._iframeWorld;
+          } else {
+            return this._mainWorld;
+          }
   }
 
   _mainContext(): Promise<dom.FrameExecutionContext> {
@@ -749,79 +813,73 @@
   }
 
   async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean, world?: types.World } = {}, arg?: any): Promise<js.JSHandle<any>> {
-    const context = await this._context(options.world ?? 'main');
-    const value = await context.evaluateExpressionHandle(expression, options, arg);
-    return value;
+
+          const context = await this._context(options.world ?? "utility");
+          const value = await context.evaluateExpressionHandle(expression, options, arg);
+          return value;
+        
   }
 
   async querySelector(selector: string, options: types.StrictOptions): Promise<dom.ElementHandle<Element> | null> {
-    debugLogger.log('api', `    finding element using the selector "${selector}"`);
-    return this.selectors.query(selector, options);
+
+          return this.querySelectorAll(selector, options).then((handles) => {
+            if (handles.length === 0)
+              return null;
+            if (handles.length > 1 && options?.strict)
+              throw new Error(`Strict mode: expected one element matching selector "${selector}", found ${handles.length}`);
+            return handles[0];
+          });
+        
   }
 
   async waitForSelector(progress: Progress, selector: string, performActionPreChecksAndLog: boolean, options: types.WaitForElementOptions, scope?: dom.ElementHandle): Promise<dom.ElementHandle<Element> | null> {
-    if ((options as any).visibility)
-      throw new Error('options.visibility is not supported, did you mean options.state?');
-    if ((options as any).waitFor && (options as any).waitFor !== 'visible')
-      throw new Error('options.waitFor is not supported, did you mean options.state?');
-    const { state = 'visible' } = options;
-    if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
-      throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
-    if (performActionPreChecksAndLog)
-      progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecksAndLog)
-        await this._page.performActionPreChecks(progress);
 
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved) {
-        if (state === 'hidden' || state === 'detached')
-          return null;
-        return continuePolling;
-      }
-      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, root }) => {
-        if (root && !root.isConnected)
-          throw injected.createStacklessError('Element is not attached to the DOM');
-        const elements = injected.querySelectorAll(info.parsed, root || document);
-        const element: Element | undefined  = elements[0];
-        const visible = element ? injected.utils.isElementVisible(element) : false;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`;
-        }
-        injected.checkDeprecatedSelectorUsage(info.parsed, elements);
-        return { log, element, visible, attached: !!element };
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));
-      const { log, visible, attached } = await progress.race(result.evaluate(r => ({ log: r.log, visible: r.visible, attached: r.attached })));
-      if (log)
-        progress.log(log);
-      const success = { attached, detached: !attached, visible, hidden: !visible }[state];
-      if (!success) {
-        result.dispose();
-        return continuePolling;
-      }
-      if (options.omitReturnValue) {
-        result.dispose();
-        return null;
-      }
-      const element = state === 'attached' || state === 'visible' ? await progress.race(result.evaluateHandle(r => r.element)) : null;
-      result.dispose();
-      if (!element)
-        return null;
-      if ((options as any).__testHookBeforeAdoptNode)
-        await progress.race((options as any).__testHookBeforeAdoptNode());
-      try {
-        const mainContext = await progress.race(resolved.frame._mainContext());
-        return await progress.race(element._adoptTo(mainContext));
-      } catch (e) {
-        return continuePolling;
-      }
-    });
-    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+          if ((options as any).visibility)
+            throw new Error('options.visibility is not supported, did you mean options.state?');
+          if ((options as any).waitFor && (options as any).waitFor !== 'visible')
+            throw new Error('options.waitFor is not supported, did you mean options.state?');
+          const { state = 'visible' } = options;
+          if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
+            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
+          if (performActionPreChecksAndLog)
+            progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);
+
+          const promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, true, async handle => {
+            const attached = !!handle;
+            var visible = false;
+            if (attached) {
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                visible = await handle.parentNode.evaluateInUtility(([injected, node, { handle }]) => {
+                  return handle ? injected.utils.isElementVisible(handle) : false;
+                }, { handle });
+              } else {
+                visible = await handle.parentNode.evaluate((injected, { handle }) => {
+                  return handle ? injected.utils.isElementVisible(handle) : false;
+                }, { handle });
+              }
+            }
+
+            const success = {
+              attached,
+              detached: !attached,
+              visible,
+              hidden: !visible
+            }[state];
+            if (!success) return "internal:continuepolling";
+            if (options.omitReturnValue) return null;
+
+            const element = state === 'attached' || state === 'visible' ? handle : null;
+            if (!element) return null;
+            if (options.__testHookBeforeAdoptNode) await options.__testHookBeforeAdoptNode();
+            try {
+              return element;
+            } catch (e) {
+              return "internal:continuepolling";
+            }
+          }, "returnOnNotResolved");
+
+          return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+        
   }
 
   async dispatchEvent(progress: Progress, selector: string, type: string, eventInit: Object = {}, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<void> {
@@ -832,18 +890,27 @@
 
   async evalOnSelector(selector: string, strict: boolean, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {
     const handle = await this.selectors.query(selector, { strict }, scope);
-    if (!handle)
-      throw new Error(`Failed to find element matching selector "${selector}"`);
-    const result = await handle.evaluateExpression(expression, { isFunction }, arg);
-    handle.dispose();
-    return result;
+            if (!handle)
+              throw new Error('Failed to find element matching selector "' + selector + '"');
+            const result = await handle.evaluateExpression(expression, { isFunction }, arg, true);
+            handle.dispose();
+            return result;
   }
 
-  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {
-    const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope);
-    const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg);
-    arrayHandle.dispose();
-    return result;
+  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle, isolatedContext?: boolean): Promise<any> {
+
+          try {
+            isolatedContext = this.selectors._parseSelector(selector, { strict: false }).world !== "main" && isolatedContext;
+            const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope, isolatedContext);
+            const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg, isolatedContext);
+            arrayHandle.dispose();
+            return result;
+          } catch (e) {
+            // Do i look like i know whats going on here?
+            if ("JSHandles can be evaluated only in the context they were created!" === e.message) return await this.evalOnSelectorAll(selector, expression, isFunction, arg, scope, isolatedContext);
+            throw e;
+          }
+        
   }
 
   async maskSelectors(selectors: ParsedSelector[], color: string): Promise<void> {
@@ -855,17 +922,35 @@
   }
 
   async querySelectorAll(selector: string): Promise<dom.ElementHandle<Element>[]> {
-    return this.selectors.queryAll(selector);
+
+          const metadata = { internal: false, log: [], method: "querySelectorAll" };
+          const progress = {
+            log: message => metadata.log.push(message),
+            metadata,
+            race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+          }
+          return await this._retryWithoutProgress(progress, selector, null, false, async (result) => {
+            if (!result || !result[0]) return [];
+            return result[1];
+          }, 'returnAll', null);
+        
   }
 
   async queryCount(selector: string, options: any): Promise<number> {
-    try {
-      return await this.selectors.queryCount(selector, options);
-    } catch (e) {
-      if (this.isNonRetriableError(e))
-        throw e;
-      return 0;
-    }
+
+          const metadata = { internal: false, log: [], method: "queryCount" };
+          const progress = {
+            log: message => metadata.log.push(message),
+            metadata,
+            race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+          }
+          return await this._retryWithoutProgress(progress, selector, null, false, async (result) => {
+            if (!result) return 0;
+            const handle = result[0];
+            const handles = result[1];
+            return handle ? handles.length : 0;
+          }, 'returnAll', null);
+        
   }
 
   async content(): Promise<string> {
@@ -887,29 +972,23 @@
   }
 
   async setContent(progress: Progress, html: string, options: types.NavigateOptions): Promise<void> {
-    const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
-    await this.raceNavigationAction(progress, async () => {
-      const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
-      progress.log(`setting frame content, waiting until "${waitUntil}"`);
-      const context = await progress.race(this._utilityContext());
-      const tagPromise = new ManualPromise<void>();
-      this._page.frameManager._consoleMessageTags.set(tag, () => {
-        // Clear lifecycle right after document.open() - see 'tag' below.
-        this._onClearLifecycle();
-        tagPromise.resolve();
-      });
-      const lifecyclePromise = progress.race(tagPromise).then(() => this.waitForLoadState(progress, waitUntil));
-      const contentPromise = progress.race(context.evaluate(({ html, tag }) => {
-        document.open();
-        console.debug(tag);  // eslint-disable-line no-console
-        document.write(html);
-        document.close();
-      }, { html, tag }));
-      await Promise.all([contentPromise, lifecyclePromise]);
-      return null;
-    }).finally(() => {
-      this._page.frameManager._consoleMessageTags.delete(tag);
-    });
+
+          await this.raceNavigationAction(progress, async () => {
+            const waitUntil = options.waitUntil === void 0 ? "load" : options.waitUntil;
+            progress.log(`setting frame content, waiting until "${waitUntil}"`);
+            const lifecyclePromise = new Promise((resolve, reject) => {
+              this._onClearLifecycle();
+              this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
+            });
+            const setContentPromise = this._page.delegate._mainFrameSession._client.send("Page.setDocumentContent", {
+              frameId: this._id,
+              html
+            });
+            await Promise.all([setContentPromise, lifecyclePromise]);
+
+            return null;
+          });
+        
   }
 
   name(): string {
@@ -1101,60 +1180,13 @@
     progress: Progress,
     selector: string,
     options: { strict?: boolean, noAutoWaiting?: boolean, force?: boolean, performActionPreChecks?: boolean },
-    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>): Promise<R> {
-    progress.log(`waiting for ${this._asLocator(selector)}`);
-    const noAutoWaiting = (options as any).__testHookNoAutoWaiting ?? options.noAutoWaiting;
-    const performActionPreChecks = (options.performActionPreChecks ?? !options.force) && !noAutoWaiting;
-    return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecks)
-        await this._page.performActionPreChecks(progress);
+    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>, returnAction: boolean | undefined): Promise<R> {
 
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, { strict: options.strict }));
-      if (!resolved) {
-        if (noAutoWaiting)
-          throw new dom.NonRecoverableDOMError('Element(s) not found');
-        return continuePolling;
-      }
-      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, callId }) => {
-        const elements = injected.querySelectorAll(info.parsed, document);
-        if (callId)
-          injected.markTargetElements(new Set(elements), callId);
-        const element = elements[0] as Element | undefined;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${injected.previewNode(element)}`;
-        }
-        injected.checkDeprecatedSelectorUsage(info.parsed, elements);
-        return { log, success: !!element, element };
-      }, { info: resolved.info, callId: progress.metadata.id }));
-      const { log, success } = await progress.race(result.evaluate(r => ({ log: r.log, success: r.success })));
-      if (log)
-        progress.log(log);
-      if (!success) {
-        if (noAutoWaiting)
-          throw new dom.NonRecoverableDOMError('Element(s) not found');
-        result.dispose();
-        return continuePolling;
-      }
-      const element = await progress.race(result.evaluateHandle(r => r.element)) as dom.ElementHandle<Element>;
-      result.dispose();
-      try {
-        const result = await action(element);
-        if (result === 'error:notconnected') {
-          if (noAutoWaiting)
-            throw new dom.NonRecoverableDOMError('Element is not attached to the DOM');
-          progress.log('element was detached from the DOM, retrying');
-          return continuePolling;
-        }
-        return result;
-      } finally {
-        element?.dispose();
-      }
-    });
+          progress.log("waiting for " + this._asLocator(selector));
+          return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
+            return this._retryWithoutProgress(progress, selector, strict, performActionPreChecks, action, returnAction, continuePolling);
+          });
+        
   }
 
   async rafrafTimeoutScreenshotElementWithProgress(progress: Progress, selector: string, timeout: number, options: ScreenshotOptions): Promise<Buffer> {
@@ -1307,20 +1339,61 @@
   }
 
   async isVisibleInternal(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
-    try {
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved)
-        return false;
-      return await progress.race(resolved.injected.evaluate((injected, { info, root }) => {
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        const state = element ? injected.elementState(element, 'visible') : { matches: false, received: 'error:notconnected' };
-        return state.matches;
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));
-    } catch (e) {
-      if (this.isNonRetriableError(e))
-        throw e;
-      return false;
-    }
+
+          try {
+            const metadata = { internal: false, log: [], method: "isVisible" };
+            const progress = {
+              log: message => metadata.log.push(message),
+              metadata,
+              race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+            }
+            progress.log("waiting for " + this._asLocator(selector));
+            if (selector === ":scope") {
+              const scopeParentNode = scope.parentNode || scope;
+              if (scopeParentNode.constructor.name == "ElementHandle") {
+                return await scopeParentNode.evaluateInUtility(([injected, node, { scope: handle2 }]) => {
+                  const state = handle2 ? injected.elementState(handle2, "visible") : {
+                    matches: false,
+                    received: "error:notconnected"
+                  };
+                  return state.matches;
+                }, { scope });
+              } else {
+                return await scopeParentNode.evaluate((injected, node, { scope: handle2 }) => {
+                  const state = handle2 ? injected.elementState(handle2, "visible") : {
+                    matches: false,
+                    received: "error:notconnected"
+                  };
+                  return state.matches;
+                }, { scope });
+              }
+            } else {
+              return await this._retryWithoutProgress(progress, selector, options.strict, false, async (handle) => {
+                if (!handle) return false;
+                if (handle.parentNode.constructor.name == "ElementHandle") {
+                  return await handle.parentNode.evaluateInUtility(([injected, node, { handle: handle2 }]) => {
+                    const state = handle2 ? injected.elementState(handle2, "visible") : {
+                      matches: false,
+                      received: "error:notconnected"
+                    };
+                    return state.matches;
+                  }, { handle });
+                } else {
+                  return await handle.parentNode.evaluate((injected, { handle: handle2 }) => {
+                    const state = handle2 ? injected.elementState(handle2, "visible") : {
+                      matches: false,
+                      received: "error:notconnected"
+                    };
+                    return state.matches;
+                  }, { handle });
+                }
+              }, "returnOnNotResolved", null);
+            }
+          } catch (e) {
+            if (this.isNonRetriableError(e)) throw e;
+            return false;
+          }
+        
   }
 
   async isHidden(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
@@ -1443,47 +1516,76 @@
   }
 
   private async _expectInternal(progress: Progress, selector: string | undefined, options: FrameExpectParams, lastIntermediateResult: { received?: any, isSet: boolean, errorMessage?: string }, noAbort: boolean) {
-    // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.
-    const race = <T>(p: Promise<T>) => noAbort ? p : progress.race(p);
-    const selectorInFrame = selector ? await race(this.selectors.resolveFrameForSelector(selector, { strict: true })) : undefined;
 
-    const { frame, info } = selectorInFrame || { frame: this, info: undefined };
-    const world = options.expression === 'to.have.property' ? 'main' : (info?.world ?? 'utility');
-    const context = await race(frame._context(world));
-    const injected = await race(context.injectedScript());
+          // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.
+          const race = (p) => noAbort ? p : progress.race(p);
+          const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
+          var log, matches, received, missingReceived;
+          if (selector) {
+            const { frame, info } = await race(this.selectors.resolveFrameForSelector(selector, { strict: true }));
+            const action = async result => {
+              if (!result) {
+                if (options.expectedNumber === 0)
+                  return { matches: true };
+                // expect(locator).toBeHidden() passes when there is no element.
+                if (!options.isNot && options.expression === 'to.be.hidden')
+                  return { matches: true };
+                // expect(locator).not.toBeVisible() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.visible')
+                  return { matches: false };
+                // expect(locator).toBeAttached({ attached: false }) passes when there is no element.
+                if (!options.isNot && options.expression === 'to.be.detached')
+                  return { matches: true };
+                // expect(locator).not.toBeAttached() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.attached')
+                  return { matches: false };
+                // expect(locator).not.toBeInViewport() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.in.viewport')
+                  return { matches: false };
+                // When none of the above applies, expect does not match.
+                return { matches: options.isNot, missingReceived: true };
+              }
 
-    const { log, matches, received, missingReceived } = await race(injected.evaluate(async (injected, { info, options, callId }) => {
-      const elements = info ? injected.querySelectorAll(info.parsed, document) : [];
-      if (callId)
-        injected.markTargetElements(new Set(elements), callId);
-      const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
-      let log = '';
-      if (isArray)
-        log = `  locator resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`;
-      else if (elements.length > 1)
-        throw injected.strictModeViolationError(info!.parsed, elements);
-      else if (elements.length)
-        log = `  locator resolved to ${injected.previewNode(elements[0])}`;
-      if (info)
-        injected.checkDeprecatedSelectorUsage(info.parsed, elements);
-      return { log, ...await injected.expect(elements[0], options, elements) };
-    }, { info, options, callId: progress.metadata.id }));
+              const handle = result[0];
+              const handles = result[1];
 
-    if (log)
-      progress.log(log);
-    // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
-    if (matches === options.isNot) {
-      if (missingReceived) {
-        lastIntermediateResult.errorMessage = 'Error: element(s) not found';
-      } else {
-        lastIntermediateResult.errorMessage = undefined;
-        lastIntermediateResult.received = received;
-      }
-      lastIntermediateResult.isSet = true;
-      if (!missingReceived && !Array.isArray(received))
-        progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
-    }
-    return { matches, received };
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                return await handle.parentNode.evaluateInUtility(async ([injected, node, { handle, options, handles }]) => {
+                  return await injected.expect(handle, options, handles);
+                }, { handle, options, handles });
+              } else {
+                return await handle.parentNode.evaluate(async (injected, { handle, options, handles }) => {
+                  return await injected.expect(handle, options, handles);
+                }, { handle, options, handles });
+              }
+            }
+
+            if (noAbort) {
+              var { log, matches, received, missingReceived } = await this._retryWithoutProgress(progress, selector, !isArray, false, action, 'returnAll', null);
+            } else {
+              var { log, matches, received, missingReceived } = await race(this._retryWithProgressIfNotConnected(progress, selector, !isArray, false, action, 'returnAll'));
+            }
+          } else {
+            const world = options.expression === 'to.have.property' ? 'main' : 'utility';
+            const context = await race(this._context(world));
+            const injected = await race(context.injectedScript());
+            var { matches, received, missingReceived } = await race(injected.evaluate(async (injected, { options, callId }) => {
+              return { ...await injected.expect(undefined, options, []) };
+            }, { options, callId: progress.metadata.id }));
+          }
+
+
+          if (log)
+            progress.log(log);
+          // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
+          if (matches === options.isNot) {
+            lastIntermediateResult.received = missingReceived ? '<element(s) not found>' : received;
+            lastIntermediateResult.isSet = true;
+            if (!missingReceived && !Array.isArray(received))
+              progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
+          }
+          return { matches, received };
+        
   }
 
   async waitForFunctionExpression<R>(progress: Progress, expression: string, isFunction: boolean | undefined, arg: any, options: { pollingInterval?: number }, world: types.World = 'main'): Promise<js.SmartHandle<R>> {
@@ -1599,29 +1701,71 @@
   }
 
   private async _callOnElementOnceMatches<T, R>(progress: Progress, selector: string, body: ElementCallback<T, R>, taskData: T, options: types.StrictOptions & { mainWorld?: boolean }, scope?: dom.ElementHandle): Promise<R> {
-    const callbackText = body.toString();
-    progress.log(`waiting for ${this._asLocator(selector)}`);
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved)
-        return continuePolling;
-      const { log, success, value } = await progress.race(resolved.injected.evaluate((injected, { info, callbackText, taskData, callId, root }) => {
-        const callback = injected.eval(callbackText) as ElementCallback<T, R>;
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        if (!element)
-          return { success: false };
-        const log = `  locator resolved to ${injected.previewNode(element)}`;
-        if (callId)
-          injected.markTargetElements(new Set([element]), callId);
-        return { log, success: true, value: callback(injected, element, taskData as T) };
-      }, { info: resolved.info, callbackText, taskData, callId: progress.metadata.id, root: resolved.frame === this ? scope : undefined }));
-      if (log)
-        progress.log(log);
-      if (!success)
-        return continuePolling;
-      return value!;
-    });
-    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+
+          const callbackText = body.toString();
+          progress.log("waiting for "+ this._asLocator(selector));
+          var promise;
+          if (selector === ":scope") {
+            const scopeParentNode = scope.parentNode || scope;
+            if (scopeParentNode.constructor.name == "ElementHandle") {
+              promise = scopeParentNode.evaluateInUtility(([injected, node, { callbackText: callbackText2, scope: handle2, taskData: taskData2 }]) => {
+                const callback = injected.eval(callbackText2);
+                return callback(injected, handle2, taskData2);
+              }, {
+                callbackText,
+                scope,
+                taskData
+              });
+            } else {
+              promise = scopeParentNode.evaluate((injected, { callbackText: callbackText2, scope: handle2, taskData: taskData2 }) => {
+                const callback = injected.eval(callbackText2);
+                return callback(injected, handle2, taskData2);
+              }, {
+                callbackText,
+                scope,
+                taskData
+              });
+            }
+          } else {
+            promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, false, async (handle) => {
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                // Handling dispatch_event's in isolated and Main Contexts
+                const [taskScope] = Object.values(taskData?.eventInit ?? {});
+                if (taskScope) {
+                  const taskScopeContext = taskScope._context;
+                  const adoptedHandle = await handle._adoptTo(taskScopeContext);
+                  return await taskScopeContext.evaluate(([injected, node, { callbackText: callbackText2, adoptedHandle: handle2, taskData: taskData2 }]) => {
+                    const callback = injected.eval(callbackText2);
+                    return callback(injected, handle2, taskData2);
+                  }, [
+                    await taskScopeContext.injectedScript(),
+                    adoptedHandle,
+                    { callbackText, adoptedHandle, taskData },
+                  ]);
+                }
+
+                return await handle.parentNode.evaluateInUtility(([injected, node, { callbackText: callbackText2, handle: handle2, taskData: taskData2 }]) => {
+                  const callback = injected.eval(callbackText2);
+                  return callback(injected, handle2, taskData2);
+                }, {
+                  callbackText,
+                  handle,
+                  taskData
+                });
+              } else {
+                return await handle.parentNode.evaluate((injected, { callbackText: callbackText2, handle: handle2, taskData: taskData2 }) => {
+                  const callback = injected.eval(callbackText2);
+                  return callback(injected, handle2, taskData2);
+                }, {
+                  callbackText,
+                  handle,
+                  taskData
+                });
+              }
+            })
+          }
+          return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+        
   }
 
   private _setContext(world: types.World, context: dom.FrameExecutionContext | null) {
@@ -1688,6 +1832,257 @@
   private _asLocator(selector: string) {
     return asLocator(this._page.browserContext._browser.sdkLanguage(), selector);
   }
+
+  _isolatedWorld: dom.FrameExecutionContext;
+  _mainWorld: dom.FrameExecutionContext;
+  _iframeWorld: dom.FrameExecutionContext;
+
+  async _getFrameMainFrameContextId(client): Promise<number> {
+
+          try {
+            var globalDocument = await client._sendMayFail("DOM.getFrameOwner", {frameId: this._id,});
+            if (globalDocument && globalDocument.nodeId) {
+              var describedNode = await client._sendMayFail("DOM.describeNode", {
+                backendNodeId: globalDocument.backendNodeId,
+              });
+              if (describedNode) {
+                var resolvedNode = await client._sendMayFail("DOM.resolveNode", {
+                  nodeId: describedNode.node.contentDocument.nodeId,
+                });
+                var _executionContextId = parseInt(resolvedNode.object.objectId.split(".")[1], 10);
+                return _executionContextId;
+              }
+            }
+          } catch (e) {}
+          return 0;
+        
+  }
+
+  async _retryWithoutProgress(progress, selector, strict, performActionPreChecks, action, returnAction, continuePolling) {
+
+          if (performActionPreChecks) await this._page.performActionPreChecks(progress);
+          const resolved = await this.selectors.resolveInjectedForSelector(selector, { strict });
+          if (!resolved) {
+            if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') {
+              const result = await action(null);
+              return result === "internal:continuepolling" ? continuePolling : result;
+            }
+            return continuePolling;
+          }
+
+          try {
+            var client = this._page.delegate._sessionForFrame(resolved.frame)._client;
+          } catch (e) {
+            var client = this._page.delegate._mainFrameSession._client;
+          }
+          var utilityContext = await resolved.frame._utilityContext();
+          var mainContext = await resolved.frame._mainContext();
+          const documentNode = await client._sendMayFail('Runtime.evaluate', {
+            expression: "document",
+            serializationOptions: {
+              serialization: "idOnly"
+            },
+            contextId: utilityContext.delegate._contextId,
+          });
+          if (!documentNode) return continuePolling;
+          const documentScope = new dom.ElementHandle(utilityContext, documentNode.result.objectId);
+
+          let currentScopingElements;
+          try {
+            currentScopingElements = await this._customFindElementsByParsed(resolved, client, mainContext, documentScope, progress, resolved.info.parsed);
+          } catch (e) {
+            if ("JSHandles can be evaluated only in the context they were created!" === e.message) return continuePolling3;
+            await progress.race(resolved.injected.evaluateHandle((injected, { error }) => { throw error }, { error: e }));
+          }
+
+          if (currentScopingElements.length == 0) {
+            // TODO: Dispose?
+            if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') {
+            const result = await action(null);
+            return result === "internal:continuepolling" ? continuePolling2 : result;
+          }
+            return continuePolling;
+          }
+          const resultElement = currentScopingElements[0];
+          if (currentScopingElements.length > 1) {
+            if (resolved.info.strict) {
+              await progress.race(resolved.injected.evaluateHandle((injected, {
+                info,
+                elements
+              }) => {
+                throw injected.strictModeViolationError(info.parsed, elements);
+              }, {
+                info: resolved.info,
+                elements: currentScopingElements
+              }));
+            }
+            progress.log("  locator resolved to " + currentScopingElements.length + " elements. Proceeding with the first one: " + resultElement.preview());
+          } else if (resultElement) {
+            progress.log("  locator resolved to " + resultElement.preview());
+          }
+
+          try {
+            var result = null;
+            if (returnAction === 'returnAll') {
+              result = await action([resultElement, currentScopingElements]);
+            } else {
+              result = await action(resultElement);
+            }
+            if (result === 'error:notconnected') {
+              progress.log('element was detached from the DOM, retrying');
+              return continuePolling;
+            } else if (result === 'internal:continuepolling') {
+              return continuePolling;
+            }
+            return result;
+          } finally {}
+        
+  }
+
+  async _customFindElementsByParsed(resolved, client, context, documentScope, progress, parsed) {
+
+          var parsedEdits = { ...parsed };
+          // Note: We start scoping at document level
+          var currentScopingElements = [documentScope];
+          while (parsed.parts.length > 0) {
+            var part = parsed.parts.shift();
+            parsedEdits.parts = [part];
+            // Getting All Elements
+            var elements = [];
+            var elementsIndexes = [];
+
+            if (part.name == "nth") {
+              const partNth = Number(part.body);
+              // Check if any Elements are currently scoped, else return empty array to continue polling
+              if (currentScopingElements.length == 0) return [];
+              // Check if the partNth is within the bounds of currentScopingElements
+              if (partNth > currentScopingElements.length-1 || partNth < -(currentScopingElements.length-1)) {
+                if (parsed.capture !== undefined) throw new Error("Can't query n-th element in a request with the capture.");
+                return [];
+              } else {
+                currentScopingElements = [currentScopingElements.at(partNth)];
+                continue;
+              }
+            } else if (part.name == "internal:or") {
+              var orredElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+              elements = currentScopingElements.concat(orredElements);
+            } else if (part.name == "internal:and") {
+              var andedElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+              const backendNodeIds = new Set(andedElements.map(item => item.backendNodeId));
+              elements = currentScopingElements.filter(item => backendNodeIds.has(item.backendNodeId));
+            } else {
+              for (const scope of currentScopingElements) {
+                const describedScope = await client.send('DOM.describeNode', {
+                  objectId: scope._objectId,
+                  depth: -1,
+                  pierce: true
+                });
+
+                // Elements Queryed in the "current round"
+                var queryingElements = [];
+                function findClosedShadowRoots(node, results = []) {
+                  if (!node || typeof node !== 'object') return results;
+                  if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                    for (const shadowRoot of node.shadowRoots) {
+                      if (shadowRoot.shadowRootType === 'closed' && shadowRoot.backendNodeId) {
+                        results.push(shadowRoot.backendNodeId);
+                      }
+                      findClosedShadowRoots(shadowRoot, results);
+                    }
+                  }
+                  if (node.nodeName !== 'IFRAME' && node.children && Array.isArray(node.children)) {
+                    for (const child of node.children) {
+                      findClosedShadowRoots(child, results);
+                    }
+                  }
+                  return results;
+                }
+
+                var shadowRootBackendIds = findClosedShadowRoots(describedScope.node);
+                var shadowRoots = [];
+                for (var shadowRootBackendId of shadowRootBackendIds) {
+                  var resolvedShadowRoot = await client.send('DOM.resolveNode', {
+                    backendNodeId: shadowRootBackendId,
+                    contextId: context.delegate._contextId
+                  });
+                  shadowRoots.push(new dom.ElementHandle(context, resolvedShadowRoot.object.objectId));
+                }
+
+                for (var shadowRoot of shadowRoots) {
+                  const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                   const elements = injected.querySelectorAll(parsed, node);
+                    if (callId) injected.markTargetElements(new Set(elements), callId);
+                    return elements
+                  }, {
+                    parsed: parsedEdits,
+                    callId: progress.metadata.id
+                  });
+
+                  const shadowElementsAmount = await shadowElements.getProperty("length");
+                  queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+                }
+
+                // Document Root Elements (not in CSR)
+                const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                  const elements = injected.querySelectorAll(parsed, node);
+                  if (callId) injected.markTargetElements(new Set(elements), callId);
+                  return elements
+                }, {
+                  parsed: parsedEdits,
+                  callId: progress.metadata.id
+                });
+                const rootElementsAmount = await rootElements.getProperty("length");
+                queryingElements.push([rootElements, rootElementsAmount, scope]);
+
+                // Querying and Sorting the elements by their backendNodeId
+                for (var queryedElement of queryingElements) {
+                  var elementsToCheck = queryedElement[0];
+                  var elementsAmount = await queryedElement[1].jsonValue();
+                  var parentNode = queryedElement[2];
+                  for (var i = 0; i < elementsAmount; i++) {
+                    if (parentNode.constructor.name == "ElementHandle") {
+                      var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck }]) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+                    } else {
+                      var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck }) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+                    }
+                    // For other Functions/Utilities
+                    elementToCheck.parentNode = parentNode;
+                    var resolvedElement = await client.send('DOM.describeNode', {
+                      objectId: elementToCheck._objectId,
+                      depth: -1,
+                    });
+                    // Note: Possible Bug, Maybe well actually have to check the Documents Node Position instead of using the backendNodeId
+                    elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+                    elementToCheck.nodePosition = this.selectors._findElementPositionInDomTree(elementToCheck, describedScope.node, context, "");
+                    elements.push(elementToCheck);
+                  }
+                }
+              }
+            }
+
+            // Sorting elements by their nodePosition, which is a index to the Element in the DOM tree
+            const getParts = (pos) => (pos || '').split('.').filter(Boolean).map(Number);
+            elements.sort((a, b) => {
+              const partA = getParts(a.nodePosition);
+              const partB = getParts(b.nodePosition);
+              const maxLength = Math.max(partA.length, partB.length);
+
+              for (let i = 0; i < maxLength; i++) {
+                const aVal = partA[i] ?? -1;
+                const bVal = partB[i] ?? -1;
+                if (aVal !== bVal) return aVal - bVal;
+              }
+              return 0;
+            });
+
+            // Remove duplicates by backendNodeId, keeping the first occurrence
+            currentScopingElements = Array.from(
+              new Map(elements.map((e) => [e.backendNodeId, e])).values()
+            );
+          }
+          return currentScopingElements;
+        
+  }
 }
 
 class SignalBarrier {
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/javascript.ts patchright/packages/playwright-core/src/server/javascript.ts
---
+++
@@ -149,17 +149,37 @@
     return evaluate(this._context, false /* returnByValue */, pageFunction, this, arg);
   }
 
-  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any) {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: true }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean) {
 
-  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any): Promise<JSHandle<any>> {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: false }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+          let context = this._context;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = context.frame;
+              if (frame) {
+                  if (isolatedContext === true) context = await frame._utilityContext();
+                  else if (isolatedContext === false) context = await frame._mainContext();
+              }
+          }
+        
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: true }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
+
+  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean): Promise<JSHandle<any>> {
+
+          let context = this._context;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = this._context.frame;
+              if (frame) {
+                  if (isolatedContext === true) context = await frame._utilityContext();
+                  else if (isolatedContext === false) context = await frame._mainContext();
+              }
+          }
+        
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: false }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
 
   async getProperty(propertyName: string): Promise<JSHandle> {
     const objectHandle = await this.evaluateHandle((object: any, propertyName) => {
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/page.ts patchright/packages/playwright-core/src/server/page.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import { createPageBindingScript, deliverBindingResult, takeBindingHandle } from './pageBinding';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -324,30 +326,25 @@
   }
 
   async exposeBinding(progress: Progress, name: string, needsHandle: boolean, playwrightBinding: frames.FunctionWithSource): Promise<PageBinding> {
-    if (this._pageBindings.has(name))
-      throw new Error(`Function "${name}" has been already registered`);
-    if (this.browserContext._pageBindings.has(name))
-      throw new Error(`Function "${name}" has been already registered in the browser context`);
-    await progress.race(this.browserContext.exposePlaywrightBindingIfNeeded());
-    const binding = new PageBinding(name, playwrightBinding, needsHandle);
-    this._pageBindings.set(name, binding);
-    try {
-      await progress.race(this.delegate.addInitScript(binding.initScript));
-      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));
-      return binding;
-    } catch (error) {
-      this._pageBindings.delete(name);
-      throw error;
-    }
+
+          if (this._pageBindings.has(name))
+            throw new Error(`Function "${name}" has been already registered`);
+          if (this.browserContext._pageBindings.has(name))
+            throw new Error(`Function "${name}" has been already registered in the browser context`);
+          const binding = new PageBinding(name, playwrightBinding, needsHandle);
+          this._pageBindings.set(name, binding);
+          await this.delegate.exposeBinding(binding);
+        
   }
 
   async removeExposedBindings(bindings: PageBinding[]) {
-    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);
-    for (const binding of bindings)
-      this._pageBindings.delete(binding.name);
-    await this.delegate.removeInitScripts(bindings.map(binding => binding.initScript));
-    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\n`).join('');
-    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');
+
+          for (const key of this._pageBindings.keys()) {
+            if (!key.startsWith('__pw'))
+              this._pageBindings.delete(key);
+          }
+          await this.delegate.removeExposedBindings();
+        
   }
 
   async setExtraHTTPHeaders(progress: Progress, headers: types.HeadersArray) {
@@ -633,9 +630,10 @@
   }
 
   async removeInitScripts(initScripts: InitScript[]) {
-    const set = new Set(initScripts);
-    this.initScripts = this.initScripts.filter(script => !set.has(script));
-    await this.delegate.removeInitScripts(initScripts);
+
+          this.initScripts.splice(0, this.initScripts.length);
+          await this.delegate.removeInitScripts();
+        
   }
 
   needsRequestInterception(): boolean {
@@ -837,13 +835,6 @@
       this.browserContext.addVisitedOrigin(origin);
   }
 
-  allInitScripts() {
-    const bindings = [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()].map(binding => binding.initScript);
-    if (this.browserContext.bindingsInitScript)
-      bindings.unshift(this.browserContext.bindingsInitScript);
-    return [...bindings, ...this.browserContext.initScripts, ...this.initScripts];
-  }
-
   getBinding(name: string) {
     return this._pageBindings.get(name) || this.browserContext._pageBindings.get(name);
   }
@@ -867,6 +858,12 @@
     const snapshot = await snapshotFrameForAI(progress, this.mainFrame(), options);
     return { full: snapshot.full.join('\n'), incremental: snapshot.incremental?.join('\n') };
   }
+
+  allBindings() {
+
+          return [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()];
+        
+  }
 }
 
 export const WorkerEvent = {
@@ -911,77 +908,82 @@
     this.openScope.close(new Error('Worker closed'));
   }
 
-  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction }, arg);
-  }
+  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
 
-  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction }, arg);
-  }
-}
+          let context = await this._executionContextPromise;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      return js.evaluateExpression(context, expression, { returnByValue: true, isFunction }, arg);
+    }
 
-export class PageBinding {
-  private static kController = '__playwright__binding__controller__';
-  static kBindingName = '__playwright__binding__';
+  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
 
-  static createInitScript() {
-    return new InitScript(`
-      (() => {
-        const module = {};
-        ${rawBindingsControllerSource.source}
-        const property = '${PageBinding.kController}';
-        if (!globalThis[property])
-          globalThis[property] = new (module.exports.BindingsController())(globalThis, '${PageBinding.kBindingName}');
-      })();
-    `);
-  }
+          let context = await this._executionContextPromise;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = this._context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      return js.evaluateExpression(context, expression, { returnByValue: false, isFunction }, arg);
+    }
+}
 
-  readonly name: string;
-  readonly playwrightFunction: frames.FunctionWithSource;
-  readonly initScript: InitScript;
-  readonly needsHandle: boolean;
-  readonly cleanupScript: string;
-  forClient?: unknown;
 
-  constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
-    this.name = name;
-    this.playwrightFunction = playwrightFunction;
-    this.initScript = new InitScript(`globalThis['${PageBinding.kController}'].addBinding(${JSON.stringify(name)}, ${needsHandle})`);
-    this.needsHandle = needsHandle;
-    this.cleanupScript = `globalThis['${PageBinding.kController}'].removeBinding(${JSON.stringify(name)})`;
-  }
+      export class PageBinding {
+        readonly source: string;
+        readonly name: string;
+        readonly playwrightFunction: frames.FunctionWithSource;
+        readonly needsHandle: boolean;
+        readonly internal: boolean;
 
-  static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
-    const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;
-    try {
-      assert(context.world);
-      const binding = page.getBinding(name);
-      if (!binding)
-        throw new Error(`Function "${name}" is not exposed`);
-      let result: any;
-      if (binding.needsHandle) {
-        const handle = await context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].takeBindingHandle(arg)`, { isFunction: true }, { name, seq }).catch(e => null);
-        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, handle);
-      } else {
-        if (!Array.isArray(serializedArgs))
-          throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
-        const args = serializedArgs!.map(a => parseEvaluationResultValue(a));
-        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, ...args);
+        constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
+          this.name = name;
+          this.playwrightFunction = playwrightFunction;
+          this.source = createPageBindingScript(name, needsHandle);
+          this.needsHandle = needsHandle;
+        }
+
+        static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
+          const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;
+          try {
+            assert(context.world);
+            const binding = page.getBinding(name);
+            if (!binding)
+              throw new Error(`Function "${name}" is not exposed`);
+            let result: any;
+            if (binding.needsHandle) {
+              const handle = await context.evaluateHandle(takeBindingHandle, { name, seq }).catch(e => null);
+              result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, handle);
+            } else {
+              if (!Array.isArray(serializedArgs))
+                throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
+              const args = serializedArgs!.map(a => parseEvaluationResultValue(a));
+              result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, ...args);
+            }
+            context.evaluate(deliverBindingResult, { name, seq, result }).catch(e => debugLogger.log('error', e));
+          } catch (error) {
+            context.evaluate(deliverBindingResult, { name, seq, error }).catch(e => debugLogger.log('error', e));
+          }
+        }
       }
-      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, result }).catch(e => debugLogger.log('error', e));
-    } catch (error) {
-      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, error }).catch(e => debugLogger.log('error', e));
-    }
-  }
-}
+    
 
 export class InitScript {
   readonly source: string;
 
   constructor(source: string) {
-    this.source = `(() => {
-      ${source}
-    })();`;
+    
+            this.source = `(() => { ${source} })();`;
+          
   }
 }
 
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/pageBinding.ts patchright/packages/playwright-core/src/server/pageBinding.ts
---
+++
@@ -0,0 +1,91 @@
+
+      /**
+       * Copyright (c) Microsoft Corporation.
+       *
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       *
+       * http://www.apache.org/licenses/LICENSE-2.0
+       *
+       * Unless required by applicable law or agreed to in writing, software
+       * distributed under the License is distributed on an "AS IS" BASIS,
+       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+       * See the License for the specific language governing permissions and
+       * limitations under the License.
+       */
+      import { source } from '../utils/isomorphic/oldUtilityScriptSerializers';
+
+      import type { SerializedValue } from '../utils/isomorphic/oldUtilityScriptSerializers';
+
+      export type BindingPayload = {
+        name: string;
+        seq: number;
+        serializedArgs?: SerializedValue[],
+      };
+
+      function addPageBinding(bindingName: string, needsHandle: boolean, utilityScriptSerializersFactory: typeof source) {
+        const { serializeAsCallArgument } = utilityScriptSerializersFactory;
+        // eslint-disable-next-line no-restricted-globals
+        const binding = (globalThis as any)[bindingName];
+        if (!binding || binding.toString().startsWith("(...args) => {")) return
+        // eslint-disable-next-line no-restricted-globals
+        (globalThis as any)[bindingName] = (...args: any[]) => {
+        // eslint-disable-next-line no-restricted-globals
+          const me = (globalThis as any)[bindingName];
+          if (needsHandle && args.slice(1).some(arg => arg !== undefined))
+            throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
+          let callbacks = me['callbacks'];
+          if (!callbacks) {
+            callbacks = new Map();
+            me['callbacks'] = callbacks;
+          }
+          const seq: number = (me['lastSeq'] || 0) + 1;
+          me['lastSeq'] = seq;
+          let handles = me['handles'];
+          if (!handles) {
+            handles = new Map();
+            me['handles'] = handles;
+          }
+          const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
+          let payload: BindingPayload;
+          if (needsHandle) {
+            handles.set(seq, args[0]);
+            payload = { name: bindingName, seq };
+          } else {
+            const serializedArgs = [];
+            for (let i = 0; i < args.length; i++) {
+              serializedArgs[i] = serializeAsCallArgument(args[i], v => {
+                return { fallThrough: v };
+              });
+            }
+            payload = { name: bindingName, seq, serializedArgs };
+          }
+          binding(JSON.stringify(payload));
+          return promise;
+        };
+        // eslint-disable-next-line no-restricted-globals
+      }
+
+      export function takeBindingHandle(arg: { name: string, seq: number }) {
+        // eslint-disable-next-line no-restricted-globals
+        const handles = (globalThis as any)[arg.name]['handles'];
+        const handle = handles.get(arg.seq);
+        handles.delete(arg.seq);
+        return handle;
+      }
+
+      export function deliverBindingResult(arg: { name: string, seq: number, result?: any, error?: any }) {
+        // eslint-disable-next-line no-restricted-globals
+        const callbacks = (globalThis as any)[arg.name]['callbacks'];
+        if ('error' in arg)
+          callbacks.get(arg.seq).reject(arg.error);
+        else
+          callbacks.get(arg.seq).resolve(arg.result);
+        callbacks.delete(arg.seq);
+      }
+
+      export function createPageBindingScript(name: string, needsHandle: boolean) {
+        return `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${source})())`;
+      }
+    
\ No newline at end of file
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/server/registry/index.ts patchright/packages/playwright-core/src/server/registry/index.ts
---
+++
@@ -1484,7 +1484,7 @@
       return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;
     default: {
       const packageManagerCommand = getPackageManagerExecCommand();
-      return `${packageManagerCommand} playwright ${parameters}`;
+      return `${packageManagerCommand} patchright ${parameters}`;
     }
   }
 }
diff -ruN -x protocol.yml --minimal playwright/packages/playwright-core/src/utils/isomorphic/oldUtilityScriptSerializers.ts patchright/packages/playwright-core/src/utils/isomorphic/oldUtilityScriptSerializers.ts
---
+++
@@ -0,0 +1,292 @@
+
+      /**
+       * Copyright (c) Microsoft Corporation.
+       *
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       *
+       * http://www.apache.org/licenses/LICENSE-2.0
+       *
+       * Unless required by applicable law or agreed to in writing, software
+       * distributed under the License is distributed on an "AS IS" BASIS,
+       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+       * See the License for the specific language governing permissions and
+       * limitations under the License.
+       */
+
+      type TypedArrayKind = 'i8' | 'ui8' | 'ui8c' | 'i16' | 'ui16' | 'i32' | 'ui32' | 'f32' | 'f64' | 'bi64' | 'bui64';
+
+      export type SerializedValue =
+          undefined | boolean | number | string |
+          { v: 'null' | 'undefined' | 'NaN' | 'Infinity' | '-Infinity' | '-0' } |
+          { d: string } |
+          { u: string } |
+          { bi: string } |
+          { e: { n: string, m: string, s: string } } |
+          { r: { p: string, f: string } } |
+          { a: SerializedValue[], id: number } |
+          { o: { k: string, v: SerializedValue }[], id: number } |
+          { ref: number } |
+          { h: number } |
+          { ta: { b: string, k: TypedArrayKind } };
+
+      type HandleOrValue = { h: number } | { fallThrough: any };
+
+      type VisitorInfo = {
+        visited: Map<object, number>;
+        lastId: number;
+      };
+
+      export function source() {
+
+        function isRegExp(obj: any): obj is RegExp {
+          try {
+            return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isDate(obj: any): obj is Date {
+          try {
+            return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isURL(obj: any): obj is URL {
+          try {
+            return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isError(obj: any): obj is Error {
+          try {
+            return obj instanceof Error || (obj && Object.getPrototypeOf(obj)?.name === 'Error');
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isTypedArray(obj: any, constructor: Function): boolean {
+          try {
+            return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;
+          } catch (error) {
+            return false;
+          }
+        }
+
+        const typedArrayConstructors: Record<TypedArrayKind, Function> = {
+          i8: Int8Array,
+          ui8: Uint8Array,
+          ui8c: Uint8ClampedArray,
+          i16: Int16Array,
+          ui16: Uint16Array,
+          i32: Int32Array,
+          ui32: Uint32Array,
+          // TODO: add Float16Array once it's in baseline
+          f32: Float32Array,
+          f64: Float64Array,
+          bi64: BigInt64Array,
+          bui64: BigUint64Array,
+        };
+
+        function typedArrayToBase64(array: any) {
+          /**
+           * Firefox does not support iterating over typed arrays, so we use `.toBase64`.
+           * Error: 'Accessing TypedArray data over Xrays is slow, and forbidden in order to encourage performant code. To copy TypedArrays across origin boundaries, consider using Components.utils.cloneInto().'
+           */
+          if ('toBase64' in array)
+            return array.toBase64();
+          const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map(b => String.fromCharCode(b)).join('');
+          return btoa(binary);
+        }
+
+        function base64ToTypedArray(base64: string, TypedArrayConstructor: any) {
+          const binary = atob(base64);
+          const bytes = new Uint8Array(binary.length);
+          for (let i = 0; i < binary.length; i++)
+            bytes[i] = binary.charCodeAt(i);
+          return new TypedArrayConstructor(bytes.buffer);
+        }
+
+        function parseEvaluationResultValue(value: SerializedValue, handles: any[] = [], refs: Map<number, object> = new Map()): any {
+          if (Object.is(value, undefined))
+            return undefined;
+          if (typeof value === 'object' && value) {
+            if ('ref' in value)
+              return refs.get(value.ref);
+            if ('v' in value) {
+              if (value.v === 'undefined')
+                return undefined;
+              if (value.v === 'null')
+                return null;
+              if (value.v === 'NaN')
+                return NaN;
+              if (value.v === 'Infinity')
+                return Infinity;
+              if (value.v === '-Infinity')
+                return -Infinity;
+              if (value.v === '-0')
+                return -0;
+              return undefined;
+            }
+            if ('d' in value)
+              return new Date(value.d);
+            if ('u' in value)
+              return new URL(value.u);
+            if ('bi' in value)
+              return BigInt(value.bi);
+            if ('e' in value) {
+              const error = new Error(value.e.m);
+              error.name = value.e.n;
+              error.stack = value.e.s;
+              return error;
+            }
+            if ('r' in value)
+              return new RegExp(value.r.p, value.r.f);
+            if ('a' in value) {
+              const result: any[] = [];
+              refs.set(value.id, result);
+              for (const a of value.a)
+                result.push(parseEvaluationResultValue(a, handles, refs));
+              return result;
+            }
+            if ('o' in value) {
+              const result: any = {};
+              refs.set(value.id, result);
+              for (const { k, v } of value.o)
+                result[k] = parseEvaluationResultValue(v, handles, refs);
+              return result;
+            }
+            if ('h' in value)
+              return handles[value.h];
+            if ('ta' in value)
+              return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);
+          }
+          return value;
+        }
+
+        function serializeAsCallArgument(value: any, handleSerializer: (value: any) => HandleOrValue): SerializedValue {
+          return serialize(value, handleSerializer, { visited: new Map(), lastId: 0 });
+        }
+
+        function serialize(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo): SerializedValue {
+          if (value && typeof value === 'object') {
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Window === 'function' && value instanceof globalThis.Window)
+              return 'ref: <Window>';
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Document === 'function' && value instanceof globalThis.Document)
+              return 'ref: <Document>';
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Node === 'function' && value instanceof globalThis.Node)
+              return 'ref: <Node>';
+          }
+          return innerSerialize(value, handleSerializer, visitorInfo);
+        }
+
+        function innerSerialize(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo): SerializedValue {
+          const result = handleSerializer(value);
+          if ('fallThrough' in result)
+            value = result.fallThrough;
+          else
+            return result;
+
+          if (typeof value === 'symbol')
+            return { v: 'undefined' };
+          if (Object.is(value, undefined))
+            return { v: 'undefined' };
+          if (Object.is(value, null))
+            return { v: 'null' };
+          if (Object.is(value, NaN))
+            return { v: 'NaN' };
+          if (Object.is(value, Infinity))
+            return { v: 'Infinity' };
+          if (Object.is(value, -Infinity))
+            return { v: '-Infinity' };
+          if (Object.is(value, -0))
+            return { v: '-0' };
+
+          if (typeof value === 'boolean')
+            return value;
+          if (typeof value === 'number')
+            return value;
+          if (typeof value === 'string')
+            return value;
+          if (typeof value === 'bigint')
+            return { bi: value.toString() };
+
+          if (isError(value)) {
+            let stack;
+            if (value.stack?.startsWith(value.name + ': ' + value.message)) {
+              // v8
+              stack = value.stack;
+            } else {
+              stack = `${value.name}: ${value.message}
+${value.stack}`;
+            }
+            return { e: { n: value.name, m: value.message, s: stack } };
+          }
+          if (isDate(value))
+            return { d: value.toJSON() };
+          if (isURL(value))
+            return { u: value.toJSON() };
+          if (isRegExp(value))
+            return { r: { p: value.source, f: value.flags } };
+          for (const [k, ctor] of Object.entries(typedArrayConstructors) as [TypedArrayKind, Function][]) {
+            if (isTypedArray(value, ctor))
+              return { ta: { b: typedArrayToBase64(value), k } };
+          }
+
+          const id = visitorInfo.visited.get(value);
+          if (id)
+            return { ref: id };
+
+          if (Array.isArray(value)) {
+            const a = [];
+            const id = ++visitorInfo.lastId;
+            visitorInfo.visited.set(value, id);
+            for (let i = 0; i < value.length; ++i)
+              a.push(serialize(value[i], handleSerializer, visitorInfo));
+            return { a, id };
+          }
+
+          if (typeof value === 'object') {
+            const o: { k: string, v: SerializedValue }[] = [];
+            const id = ++visitorInfo.lastId;
+            visitorInfo.visited.set(value, id);
+            for (const name of Object.keys(value)) {
+              let item;
+              try {
+                item = value[name];
+              } catch (e) {
+                continue;  // native bindings will throw sometimes
+              }
+              if (name === 'toJSON' && typeof item === 'function')
+                o.push({ k: name, v: { o: [], id: 0 } });
+              else
+                o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });
+            }
+
+            let jsonWrapper;
+            try {
+              // If Object.keys().length === 0 we fall back to toJSON if it exists
+              if (o.length === 0 && value.toJSON && typeof value.toJSON === 'function')
+                jsonWrapper = { value: value.toJSON() };
+            } catch (e) {
+            }
+            if (jsonWrapper)
+              return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);
+
+            return { o, id };
+          }
+        }
+
+        return { parseEvaluationResultValue, serializeAsCallArgument };
+      }
+    
\ No newline at end of file
diff -ruN -x protocol.yml --minimal playwright/packages/recorder/src/recorder.tsx patchright/packages/recorder/src/recorder.tsx
---
+++
@@ -101,7 +101,7 @@
   }, [backend, mode, selectedTab, setSelectedTab, source]);
 
   React.useEffect(() => {
-    backend.setAutoExpect({ autoExpect });
+    try { window.dispatch({ event: 'setAutoExpect', params: { autoExpect } }); } catch {}
   }, [autoExpect, backend]);
 
   React.useLayoutEffect(() => {
